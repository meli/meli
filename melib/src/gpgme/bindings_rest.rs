/* automatically generated by rust-bindgen 0.70.1 */

// SPDX-License-Identifier: EUPL-1.2 OR GPL-3.0-or-later

pub type size_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __time_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
pub type gpg_error_t = ::core::ffi::c_uint;
pub type gpgrt_stream_t = *mut _gpgrt__stream;
pub type gpgme_off_t = off_t;
pub type gpgme_ssize_t = ssize_t;
pub type gpgme_ctx_t = *mut gpgme_context;
pub type gpgme_data_t = *mut gpgme_data;
pub type gpgme_error_t = gpg_error_t;
pub type gpgme_keylist_mode_t = ::core::ffi::c_uint;
pub type gpgme_export_mode_t = ::core::ffi::c_uint;
pub type gpgme_sig_notation_flags_t = ::core::ffi::c_uint;
pub type gpgme_sig_notation_t = *mut _gpgme_sig_notation;
pub type gpgme_engine_info_t = *mut _gpgme_engine_info;
pub type gpgme_tofu_info_t = *mut _gpgme_tofu_info;
pub type gpgme_subkey_t = *mut _gpgme_subkey;
pub type gpgme_key_sig_t = *mut _gpgme_key_sig;
pub type gpgme_user_id_t = *mut _gpgme_user_id;
pub type gpgme_revocation_key_t = *mut _gpgme_revocation_key;
pub type gpgme_key_t = *mut _gpgme_key;
pub type gpgme_invalid_key_t = *mut _gpgme_invalid_key;
pub type gpgme_passphrase_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        hook: *mut ::core::ffi::c_void,
        uid_hint: *const ::core::ffi::c_char,
        passphrase_info: *const ::core::ffi::c_char,
        prev_was_bad: ::core::ffi::c_int,
        fd: ::core::ffi::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_progress_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        what: *const ::core::ffi::c_char,
        type_: ::core::ffi::c_int,
        current: ::core::ffi::c_int,
        total: ::core::ffi::c_int,
    ),
>;
pub type gpgme_status_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        keyword: *const ::core::ffi::c_char,
        args: *const ::core::ffi::c_char,
    ) -> gpgme_error_t,
>;
pub type gpgme_interact_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        keyword: *const ::core::ffi::c_char,
        args: *const ::core::ffi::c_char,
        fd: ::core::ffi::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_io_cb_t = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void, fd: ::core::ffi::c_int) -> gpgme_error_t,
>;
pub type gpgme_register_io_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::core::ffi::c_void,
        fd: ::core::ffi::c_int,
        dir: ::core::ffi::c_int,
        fnc: gpgme_io_cb_t,
        fnc_data: *mut ::core::ffi::c_void,
        tag: *mut *mut ::core::ffi::c_void,
    ) -> gpgme_error_t,
>;
pub type gpgme_remove_io_cb_t =
    ::core::option::Option<unsafe extern "C" fn(tag: *mut ::core::ffi::c_void)>;
pub type gpgme_io_event_done_data_t = *mut gpgme_io_event_done_data;
pub type gpgme_event_io_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::core::ffi::c_void,
        type_: gpgme_event_io_t,
        type_data: *mut ::core::ffi::c_void,
    ),
>;
pub type gpgme_io_cbs_t = *mut gpgme_io_cbs;
pub type gpgme_data_read_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::core::ffi::c_void,
        buffer: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> ssize_t,
>;
pub type gpgme_data_write_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::core::ffi::c_void,
        buffer: *const ::core::ffi::c_void,
        size: size_t,
    ) -> ssize_t,
>;
pub type gpgme_data_seek_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::core::ffi::c_void,
        offset: off_t,
        whence: ::core::ffi::c_int,
    ) -> off_t,
>;
pub type gpgme_data_release_cb_t =
    ::core::option::Option<unsafe extern "C" fn(handle: *mut ::core::ffi::c_void)>;
pub type gpgme_data_cbs_t = *mut gpgme_data_cbs;
pub type gpgme_encrypt_result_t = *mut _gpgme_op_encrypt_result;
pub type gpgme_recipient_t = *mut _gpgme_recipient;
pub type gpgme_decrypt_result_t = *mut _gpgme_op_decrypt_result;
pub type gpgme_new_signature_t = *mut _gpgme_new_signature;
pub type gpgme_sign_result_t = *mut _gpgme_op_sign_result;
pub type gpgme_signature_t = *mut _gpgme_signature;
pub type gpgme_verify_result_t = *mut _gpgme_op_verify_result;
pub type gpgme_verify_flags_t = ::core::ffi::c_uint;
pub type gpgme_import_status_t = *mut _gpgme_import_status;
pub type gpgme_import_result_t = *mut _gpgme_op_import_result;
pub type gpgme_genkey_result_t = *mut _gpgme_op_genkey_result;
pub type gpgme_keylist_result_t = *mut _gpgme_op_keylist_result;
pub type gpgme_trust_item_t = *mut _gpgme_trust_item;
pub type gpgme_assuan_data_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        data: *const ::core::ffi::c_void,
        datalen: size_t,
    ) -> gpgme_error_t,
>;
pub type gpgme_assuan_inquire_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        name: *const ::core::ffi::c_char,
        args: *const ::core::ffi::c_char,
        r_data: *mut gpgme_data_t,
    ) -> gpgme_error_t,
>;
pub type gpgme_assuan_status_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        status: *const ::core::ffi::c_char,
        args: *const ::core::ffi::c_char,
    ) -> gpgme_error_t,
>;
pub type gpgme_vfs_mount_result_t = *mut _gpgme_op_vfs_mount_result;
pub type gpgme_conf_arg_t = *mut gpgme_conf_arg;
pub type gpgme_conf_opt_t = *mut gpgme_conf_opt;
pub type gpgme_conf_comp_t = *mut gpgme_conf_comp;
pub type gpgme_query_swdb_result_t = *mut _gpgme_op_query_swdb_result;
pub type gpgme_edit_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::core::ffi::c_void,
        status: gpgme_status_code_t,
        args: *const ::core::ffi::c_char,
        fd: ::core::ffi::c_int,
    ) -> gpgme_error_t,
>;
pub type gpgme_assuan_result_t = *mut _gpgme_op_assuan_result;
pub type GpgmeCtx = gpgme_ctx_t;
pub type GpgmeData = gpgme_data_t;
pub type GpgmeError = gpgme_error_t;
pub type GpgmeEngineInfo = gpgme_engine_info_t;
pub type GpgmeSubkey = gpgme_subkey_t;
pub type GpgmeKeySig = gpgme_key_sig_t;
pub type GpgmeUserID = gpgme_user_id_t;
pub type GpgmeKey = gpgme_key_t;
pub type GpgmePassphraseCb = gpgme_passphrase_cb_t;
pub type GpgmeProgressCb = gpgme_progress_cb_t;
pub type GpgmeIOCb = gpgme_io_cb_t;
pub type GpgmeRegisterIOCb = gpgme_register_io_cb_t;
pub type GpgmeRemoveIOCb = gpgme_remove_io_cb_t;
pub type GpgmeEventIOCb = gpgme_event_io_cb_t;
pub type GpgmeDataReadCb = gpgme_data_read_cb_t;
pub type GpgmeDataWriteCb = gpgme_data_write_cb_t;
pub type GpgmeDataSeekCb = gpgme_data_seek_cb_t;
pub type GpgmeDataReleaseCb = gpgme_data_release_cb_t;
pub type GpgmeEncryptResult = gpgme_encrypt_result_t;
pub type GpgmeSigNotation = gpgme_sig_notation_t;
pub type GpgmeSignature = gpgme_signature_t;
pub type GpgmeVerifyResult = gpgme_verify_result_t;
pub type GpgmeImportStatus = gpgme_import_status_t;
pub type GpgmeImportResult = gpgme_import_result_t;
pub type GpgmeGenKeyResult = gpgme_genkey_result_t;
pub type GpgmeTrustItem = gpgme_trust_item_t;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_stream_internal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgrt__stream {
    pub flags: _gpgrt__stream__bindgen_ty_1,
    pub buffer: *mut ::core::ffi::c_uchar,
    pub buffer_size: size_t,
    pub data_len: size_t,
    pub data_offset: size_t,
    pub data_flushed: size_t,
    pub unread_buffer: *mut ::core::ffi::c_uchar,
    pub unread_buffer_size: size_t,
    pub unread_data_len: size_t,
    pub intern: *mut _gpgrt_stream_internal,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgrt__stream__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgme_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_sig_notation {
    pub next: *mut _gpgme_sig_notation,
    pub name: *mut ::core::ffi::c_char,
    pub value: *mut ::core::ffi::c_char,
    pub name_len: ::core::ffi::c_int,
    pub value_len: ::core::ffi::c_int,
    pub flags: gpgme_sig_notation_flags_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_engine_info {
    pub next: *mut _gpgme_engine_info,
    pub protocol: gpgme_protocol_t,
    pub file_name: *mut ::core::ffi::c_char,
    pub version: *mut ::core::ffi::c_char,
    pub req_version: *const ::core::ffi::c_char,
    pub home_dir: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_tofu_info {
    pub next: *mut _gpgme_tofu_info,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub signcount: ::core::ffi::c_ushort,
    pub encrcount: ::core::ffi::c_ushort,
    pub signfirst: ::core::ffi::c_ulong,
    pub signlast: ::core::ffi::c_ulong,
    pub encrfirst: ::core::ffi::c_ulong,
    pub encrlast: ::core::ffi::c_ulong,
    pub description: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_subkey {
    pub next: *mut _gpgme_subkey,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub length: ::core::ffi::c_uint,
    pub keyid: *mut ::core::ffi::c_char,
    pub _keyid: [::core::ffi::c_char; 17usize],
    pub fpr: *mut ::core::ffi::c_char,
    pub timestamp: ::core::ffi::c_long,
    pub expires: ::core::ffi::c_long,
    pub card_number: *mut ::core::ffi::c_char,
    pub curve: *mut ::core::ffi::c_char,
    pub keygrip: *mut ::core::ffi::c_char,
    pub v5fpr: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_key_sig {
    pub next: *mut _gpgme_key_sig,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub keyid: *mut ::core::ffi::c_char,
    pub _keyid: [::core::ffi::c_char; 17usize],
    pub timestamp: ::core::ffi::c_long,
    pub expires: ::core::ffi::c_long,
    pub status: gpgme_error_t,
    pub class: ::core::ffi::c_uint,
    pub uid: *mut ::core::ffi::c_char,
    pub name: *mut ::core::ffi::c_char,
    pub email: *mut ::core::ffi::c_char,
    pub comment: *mut ::core::ffi::c_char,
    pub sig_class: ::core::ffi::c_uint,
    pub notations: gpgme_sig_notation_t,
    pub _last_notation: gpgme_sig_notation_t,
    pub trust_scope: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_user_id {
    pub next: *mut _gpgme_user_id,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub validity: gpgme_validity_t,
    pub uid: *mut ::core::ffi::c_char,
    pub name: *mut ::core::ffi::c_char,
    pub email: *mut ::core::ffi::c_char,
    pub comment: *mut ::core::ffi::c_char,
    pub signatures: gpgme_key_sig_t,
    pub _last_keysig: gpgme_key_sig_t,
    pub address: *mut ::core::ffi::c_char,
    pub tofu: gpgme_tofu_info_t,
    pub last_update: ::core::ffi::c_ulong,
    pub uidhash: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_revocation_key {
    pub next: *mut _gpgme_revocation_key,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub fpr: *mut ::core::ffi::c_char,
    pub key_class: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_key {
    pub _refs: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub protocol: gpgme_protocol_t,
    pub issuer_serial: *mut ::core::ffi::c_char,
    pub issuer_name: *mut ::core::ffi::c_char,
    pub chain_id: *mut ::core::ffi::c_char,
    pub owner_trust: gpgme_validity_t,
    pub subkeys: gpgme_subkey_t,
    pub uids: gpgme_user_id_t,
    pub _last_subkey: gpgme_subkey_t,
    pub _last_uid: gpgme_user_id_t,
    pub keylist_mode: gpgme_keylist_mode_t,
    pub fpr: *mut ::core::ffi::c_char,
    pub last_update: ::core::ffi::c_ulong,
    pub revocation_keys: gpgme_revocation_key_t,
    pub _last_revkey: gpgme_revocation_key_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_invalid_key {
    pub next: *mut _gpgme_invalid_key,
    pub fpr: *mut ::core::ffi::c_char,
    pub reason: gpgme_error_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_io_event_done_data {
    pub err: gpgme_error_t,
    pub op_err: gpgme_error_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_io_cbs {
    pub add: gpgme_register_io_cb_t,
    pub add_priv: *mut ::core::ffi::c_void,
    pub remove: gpgme_remove_io_cb_t,
    pub event: gpgme_event_io_cb_t,
    pub event_priv: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_data_cbs {
    pub read: gpgme_data_read_cb_t,
    pub write: gpgme_data_write_cb_t,
    pub seek: gpgme_data_seek_cb_t,
    pub release: gpgme_data_release_cb_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_encrypt_result {
    pub invalid_recipients: gpgme_invalid_key_t,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_encrypt_flags_t(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_recipient {
    pub next: *mut _gpgme_recipient,
    pub keyid: *mut ::core::ffi::c_char,
    pub _keyid: [::core::ffi::c_char; 17usize],
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub status: gpgme_error_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_decrypt_result {
    pub unsupported_algorithm: *mut ::core::ffi::c_char,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub recipients: gpgme_recipient_t,
    pub file_name: *mut ::core::ffi::c_char,
    pub session_key: *mut ::core::ffi::c_char,
    pub symkey_algo: *mut ::core::ffi::c_char,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_decrypt_flags_t(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_new_signature {
    pub next: *mut _gpgme_new_signature,
    pub type_: gpgme_sig_mode_t,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub hash_algo: gpgme_hash_algo_t,
    pub _obsolete_class: ::core::ffi::c_ulong,
    pub timestamp: ::core::ffi::c_long,
    pub fpr: *mut ::core::ffi::c_char,
    pub class: ::core::ffi::c_uint,
    pub sig_class: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_sign_result {
    pub invalid_signers: gpgme_invalid_key_t,
    pub signatures: gpgme_new_signature_t,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_sigsum_t(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_signature {
    pub next: *mut _gpgme_signature,
    pub summary: gpgme_sigsum_t,
    pub fpr: *mut ::core::ffi::c_char,
    pub status: gpgme_error_t,
    pub notations: gpgme_sig_notation_t,
    pub timestamp: ::core::ffi::c_ulong,
    pub exp_timestamp: ::core::ffi::c_ulong,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub validity: gpgme_validity_t,
    pub validity_reason: gpgme_error_t,
    pub pubkey_algo: gpgme_pubkey_algo_t,
    pub hash_algo: gpgme_hash_algo_t,
    pub pka_address: *mut ::core::ffi::c_char,
    pub key: gpgme_key_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_verify_result {
    pub signatures: gpgme_signature_t,
    pub file_name: *mut ::core::ffi::c_char,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_import_status {
    pub next: *mut _gpgme_import_status,
    pub fpr: *mut ::core::ffi::c_char,
    pub result: gpgme_error_t,
    pub status: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_import_result {
    pub considered: ::core::ffi::c_int,
    pub no_user_id: ::core::ffi::c_int,
    pub imported: ::core::ffi::c_int,
    pub imported_rsa: ::core::ffi::c_int,
    pub unchanged: ::core::ffi::c_int,
    pub new_user_ids: ::core::ffi::c_int,
    pub new_sub_keys: ::core::ffi::c_int,
    pub new_signatures: ::core::ffi::c_int,
    pub new_revocations: ::core::ffi::c_int,
    pub secret_read: ::core::ffi::c_int,
    pub secret_imported: ::core::ffi::c_int,
    pub secret_unchanged: ::core::ffi::c_int,
    pub skipped_new_keys: ::core::ffi::c_int,
    pub not_imported: ::core::ffi::c_int,
    pub imports: gpgme_import_status_t,
    pub skipped_v3_keys: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_genkey_result {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub fpr: *mut ::core::ffi::c_char,
    pub pubkey: gpgme_data_t,
    pub seckey: gpgme_data_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_keylist_result {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_trust_item {
    pub _refs: ::core::ffi::c_uint,
    pub keyid: *mut ::core::ffi::c_char,
    pub _keyid: [::core::ffi::c_char; 17usize],
    pub type_: ::core::ffi::c_int,
    pub level: ::core::ffi::c_int,
    pub owner_trust: *mut ::core::ffi::c_char,
    pub _owner_trust: [::core::ffi::c_char; 2usize],
    pub validity: *mut ::core::ffi::c_char,
    pub _validity: [::core::ffi::c_char; 2usize],
    pub name: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_vfs_mount_result {
    pub mount_dir: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgme_conf_arg {
    pub next: *mut gpgme_conf_arg,
    pub no_arg: ::core::ffi::c_uint,
    pub value: gpgme_conf_arg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_conf_opt {
    pub next: *mut gpgme_conf_opt,
    pub name: *mut ::core::ffi::c_char,
    pub flags: ::core::ffi::c_uint,
    pub level: gpgme_conf_level_t,
    pub description: *mut ::core::ffi::c_char,
    pub type_: gpgme_conf_type_t,
    pub alt_type: gpgme_conf_type_t,
    pub argname: *mut ::core::ffi::c_char,
    pub default_value: gpgme_conf_arg_t,
    pub default_description: *mut ::core::ffi::c_char,
    pub no_arg_value: gpgme_conf_arg_t,
    pub no_arg_description: *mut ::core::ffi::c_char,
    pub value: gpgme_conf_arg_t,
    pub change_value: ::core::ffi::c_int,
    pub new_value: gpgme_conf_arg_t,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct gpgme_conf_comp {
    pub next: *mut gpgme_conf_comp,
    pub _last_opt_p: *mut gpgme_conf_opt_t,
    pub name: *mut ::core::ffi::c_char,
    pub description: *mut ::core::ffi::c_char,
    pub program_name: *mut ::core::ffi::c_char,
    pub options: *mut gpgme_conf_opt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_query_swdb_result {
    pub next: *mut _gpgme_op_query_swdb_result,
    pub name: *mut ::core::ffi::c_char,
    pub iversion: *mut ::core::ffi::c_char,
    pub created: ::core::ffi::c_ulong,
    pub retrieved: ::core::ffi::c_ulong,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub version: *mut ::core::ffi::c_char,
    pub reldate: ::core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _gpgme_op_assuan_result {
    pub err: gpgme_error_t,
}
pub const GPGME_VERSION: &::core::ffi::CStr = c"1.24.0";
pub const GPGME_VERSION_NUMBER: u32 = 71680;
pub const GPGME_KEYLIST_MODE_LOCAL: u32 = 1;
pub const GPGME_KEYLIST_MODE_EXTERN: u32 = 2;
pub const GPGME_KEYLIST_MODE_SIGS: u32 = 4;
pub const GPGME_KEYLIST_MODE_SIG_NOTATIONS: u32 = 8;
pub const GPGME_KEYLIST_MODE_WITH_SECRET: u32 = 16;
pub const GPGME_KEYLIST_MODE_WITH_TOFU: u32 = 32;
pub const GPGME_KEYLIST_MODE_WITH_KEYGRIP: u32 = 64;
pub const GPGME_KEYLIST_MODE_EPHEMERAL: u32 = 128;
pub const GPGME_KEYLIST_MODE_VALIDATE: u32 = 256;
pub const GPGME_KEYLIST_MODE_FORCE_EXTERN: u32 = 512;
pub const GPGME_KEYLIST_MODE_WITH_V5FPR: u32 = 1024;
pub const GPGME_KEYLIST_MODE_LOCATE: u32 = 3;
pub const GPGME_KEYLIST_MODE_LOCATE_EXTERNAL: u32 = 515;
pub const GPGME_EXPORT_MODE_EXTERN: u32 = 2;
pub const GPGME_EXPORT_MODE_MINIMAL: u32 = 4;
pub const GPGME_EXPORT_MODE_SECRET: u32 = 16;
pub const GPGME_EXPORT_MODE_RAW: u32 = 32;
pub const GPGME_EXPORT_MODE_PKCS12: u32 = 64;
pub const GPGME_EXPORT_MODE_SSH: u32 = 256;
pub const GPGME_EXPORT_MODE_SECRET_SUBKEY: u32 = 512;
pub const GPGME_AUDITLOG_DEFAULT: u32 = 0;
pub const GPGME_AUDITLOG_HTML: u32 = 1;
pub const GPGME_AUDITLOG_DIAG: u32 = 2;
pub const GPGME_AUDITLOG_WITH_HELP: u32 = 128;
pub const GPGME_SIG_NOTATION_HUMAN_READABLE: u32 = 1;
pub const GPGME_SIG_NOTATION_CRITICAL: u32 = 2;
pub const GPGME_INCLUDE_CERTS_DEFAULT: i32 = -256;
pub const GPGME_IMPORT_NEW: u32 = 1;
pub const GPGME_IMPORT_UID: u32 = 2;
pub const GPGME_IMPORT_SIG: u32 = 4;
pub const GPGME_IMPORT_SUBKEY: u32 = 8;
pub const GPGME_IMPORT_SECRET: u32 = 16;
pub const GPGME_CREATE_SIGN: u32 = 1;
pub const GPGME_CREATE_ENCR: u32 = 2;
pub const GPGME_CREATE_CERT: u32 = 4;
pub const GPGME_CREATE_AUTH: u32 = 8;
pub const GPGME_CREATE_NOPASSWD: u32 = 128;
pub const GPGME_CREATE_SELFSIGNED: u32 = 256;
pub const GPGME_CREATE_NOSTORE: u32 = 512;
pub const GPGME_CREATE_WANTPUB: u32 = 1024;
pub const GPGME_CREATE_WANTSEC: u32 = 2048;
pub const GPGME_CREATE_FORCE: u32 = 4096;
pub const GPGME_CREATE_NOEXPIRE: u32 = 8192;
pub const GPGME_CREATE_ADSK: u32 = 16384;
pub const GPGME_DELETE_ALLOW_SECRET: u32 = 1;
pub const GPGME_DELETE_FORCE: u32 = 2;
pub const GPGME_KEYSIGN_LOCAL: u32 = 128;
pub const GPGME_KEYSIGN_LFSEP: u32 = 256;
pub const GPGME_KEYSIGN_NOEXPIRE: u32 = 512;
pub const GPGME_KEYSIGN_FORCE: u32 = 1024;
pub const GPGME_REVSIG_LFSEP: u32 = 256;
pub const GPGME_INTERACT_CARD: u32 = 1;
pub const GPGME_SPAWN_DETACHED: u32 = 1;
pub const GPGME_SPAWN_ALLOW_SET_FG: u32 = 2;
pub const GPGME_SPAWN_SHOW_WINDOW: u32 = 4;
pub const GPGME_CONF_GROUP: u32 = 1;
pub const GPGME_CONF_OPTIONAL: u32 = 2;
pub const GPGME_CONF_LIST: u32 = 4;
pub const GPGME_CONF_RUNTIME: u32 = 8;
pub const GPGME_CONF_DEFAULT: u32 = 16;
pub const GPGME_CONF_DEFAULT_DESC: u32 = 32;
pub const GPGME_CONF_NO_ARG_DESC: u32 = 64;
pub const GPGME_CONF_NO_CHANGE: u32 = 128;
pub const GPGME_EXPORT_MODE_NOUID: u32 = 128;
pub const GPGME_VERIFY_ARCHIVE: gpgme_verify_flags_t = 1;
#[test]
fn bindgen_test_layout__gpgrt__stream__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        "Size of _gpgrt__stream__bindgen_ty_1"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        "Alignment of _gpgrt__stream__bindgen_ty_1"
    );
}
#[test]
fn bindgen_test_layout__gpgrt__stream() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgrt__stream> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgrt__stream>(),
        80usize,
        "Size of _gpgrt__stream"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgrt__stream>(),
        8usize,
        "Alignment of _gpgrt__stream"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgrt__stream::flags"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgrt__stream::buffer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgrt__stream::buffer_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgrt__stream::data_len"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgrt__stream::data_offset"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_flushed) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgrt__stream::data_flushed"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unread_buffer) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgrt__stream::unread_buffer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unread_buffer_size) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgrt__stream::unread_buffer_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unread_data_len) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgrt__stream::unread_data_len"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intern) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgrt__stream::intern"
    );
}
#[test]
fn bindgen_test_layout__gpgme_sig_notation() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_sig_notation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_sig_notation>(),
        40usize,
        "Size of _gpgme_sig_notation"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_sig_notation>(),
        8usize,
        "Alignment of _gpgme_sig_notation"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_sig_notation::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_sig_notation::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_sig_notation::value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_len) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_sig_notation::name_len"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_len) as usize - ptr as usize },
        28usize,
        "Offset of field: _gpgme_sig_notation::value_len"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_sig_notation::flags"
    );
}
#[test]
fn bindgen_test_layout__gpgme_engine_info() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_engine_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_engine_info>(),
        48usize,
        "Size of _gpgme_engine_info"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_engine_info>(),
        8usize,
        "Alignment of _gpgme_engine_info"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_engine_info::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_engine_info::protocol"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_engine_info::file_name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_engine_info::version"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).req_version) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_engine_info::req_version"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).home_dir) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_engine_info::home_dir"
    );
}
#[test]
fn bindgen_test_layout__gpgme_tofu_info() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_tofu_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_tofu_info>(),
        56usize,
        "Size of _gpgme_tofu_info"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_tofu_info>(),
        8usize,
        "Alignment of _gpgme_tofu_info"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_tofu_info::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signcount) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_tofu_info::signcount"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrcount) as usize - ptr as usize },
        14usize,
        "Offset of field: _gpgme_tofu_info::encrcount"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signfirst) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_tofu_info::signfirst"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signlast) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_tofu_info::signlast"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrfirst) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_tofu_info::encrfirst"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrlast) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_tofu_info::encrlast"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_tofu_info::description"
    );
}
#[test]
fn bindgen_test_layout__gpgme_subkey() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_subkey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_subkey>(),
        112usize,
        "Size of _gpgme_subkey"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_subkey>(),
        8usize,
        "Alignment of _gpgme_subkey"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_subkey::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_subkey::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_subkey::length"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyid) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_subkey::keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._keyid) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_subkey::_keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_subkey::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_subkey::timestamp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expires) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_subkey::expires"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).card_number) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_subkey::card_number"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        88usize,
        "Offset of field: _gpgme_subkey::curve"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keygrip) as usize - ptr as usize },
        96usize,
        "Offset of field: _gpgme_subkey::keygrip"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v5fpr) as usize - ptr as usize },
        104usize,
        "Offset of field: _gpgme_subkey::v5fpr"
    );
}
#[test]
fn bindgen_test_layout__gpgme_key_sig() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_key_sig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_key_sig>(),
        136usize,
        "Size of _gpgme_key_sig"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_key_sig>(),
        8usize,
        "Alignment of _gpgme_key_sig"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_key_sig::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_key_sig::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyid) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_key_sig::keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._keyid) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_key_sig::_keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_key_sig::timestamp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expires) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_key_sig::expires"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_key_sig::status"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class) as usize - ptr as usize },
        68usize,
        "Offset of field: _gpgme_key_sig::class"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_key_sig::uid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_key_sig::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).email) as usize - ptr as usize },
        88usize,
        "Offset of field: _gpgme_key_sig::email"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        96usize,
        "Offset of field: _gpgme_key_sig::comment"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_class) as usize - ptr as usize },
        104usize,
        "Offset of field: _gpgme_key_sig::sig_class"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notations) as usize - ptr as usize },
        112usize,
        "Offset of field: _gpgme_key_sig::notations"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_notation) as usize - ptr as usize },
        120usize,
        "Offset of field: _gpgme_key_sig::_last_notation"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trust_scope) as usize - ptr as usize },
        128usize,
        "Offset of field: _gpgme_key_sig::trust_scope"
    );
}
#[test]
fn bindgen_test_layout__gpgme_user_id() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_user_id> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_user_id>(),
        96usize,
        "Size of _gpgme_user_id"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_user_id>(),
        8usize,
        "Alignment of _gpgme_user_id"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_user_id::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validity) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_user_id::validity"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_user_id::uid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_user_id::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).email) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_user_id::email"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_user_id::comment"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signatures) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_user_id::signatures"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_keysig) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_user_id::_last_keysig"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_user_id::address"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tofu) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_user_id::tofu"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_user_id::last_update"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uidhash) as usize - ptr as usize },
        88usize,
        "Offset of field: _gpgme_user_id::uidhash"
    );
}
#[test]
fn bindgen_test_layout__gpgme_revocation_key() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_revocation_key> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_revocation_key>(),
        32usize,
        "Size of _gpgme_revocation_key"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_revocation_key>(),
        8usize,
        "Alignment of _gpgme_revocation_key"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_revocation_key::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_revocation_key::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_revocation_key::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_class) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_revocation_key::key_class"
    );
}
#[test]
fn bindgen_test_layout__gpgme_key() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_key>(),
        120usize,
        "Size of _gpgme_key"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_key>(),
        8usize,
        "Alignment of _gpgme_key"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._refs) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_key::_refs"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_key::protocol"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_serial) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_key::issuer_serial"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_name) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_key::issuer_name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain_id) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_key::chain_id"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner_trust) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_key::owner_trust"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subkeys) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_key::subkeys"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uids) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_key::uids"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_subkey) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_key::_last_subkey"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_uid) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_key::_last_uid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylist_mode) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_key::keylist_mode"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        88usize,
        "Offset of field: _gpgme_key::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        96usize,
        "Offset of field: _gpgme_key::last_update"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).revocation_keys) as usize - ptr as usize },
        104usize,
        "Offset of field: _gpgme_key::revocation_keys"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_revkey) as usize - ptr as usize },
        112usize,
        "Offset of field: _gpgme_key::_last_revkey"
    );
}
#[test]
fn bindgen_test_layout__gpgme_invalid_key() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_invalid_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_invalid_key>(),
        24usize,
        "Size of _gpgme_invalid_key"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_invalid_key>(),
        8usize,
        "Alignment of _gpgme_invalid_key"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_invalid_key::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_invalid_key::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_invalid_key::reason"
    );
}
#[test]
fn bindgen_test_layout_gpgme_io_event_done_data() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_io_event_done_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_io_event_done_data>(),
        8usize,
        "Size of gpgme_io_event_done_data"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_io_event_done_data>(),
        4usize,
        "Alignment of gpgme_io_event_done_data"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_io_event_done_data::err"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_err) as usize - ptr as usize },
        4usize,
        "Offset of field: gpgme_io_event_done_data::op_err"
    );
}
#[test]
fn bindgen_test_layout_gpgme_io_cbs() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_io_cbs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_io_cbs>(),
        40usize,
        "Size of gpgme_io_cbs"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_io_cbs>(),
        8usize,
        "Alignment of gpgme_io_cbs"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_io_cbs::add"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_priv) as usize - ptr as usize },
        8usize,
        "Offset of field: gpgme_io_cbs::add_priv"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        16usize,
        "Offset of field: gpgme_io_cbs::remove"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        24usize,
        "Offset of field: gpgme_io_cbs::event"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_priv) as usize - ptr as usize },
        32usize,
        "Offset of field: gpgme_io_cbs::event_priv"
    );
}
#[test]
fn bindgen_test_layout_gpgme_data_cbs() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_data_cbs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_data_cbs>(),
        32usize,
        "Size of gpgme_data_cbs"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_data_cbs>(),
        8usize,
        "Alignment of gpgme_data_cbs"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_data_cbs::read"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        "Offset of field: gpgme_data_cbs::write"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        "Offset of field: gpgme_data_cbs::seek"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        "Offset of field: gpgme_data_cbs::release"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_encrypt_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_encrypt_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_encrypt_result>(),
        8usize,
        "Size of _gpgme_op_encrypt_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_encrypt_result>(),
        8usize,
        "Alignment of _gpgme_op_encrypt_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invalid_recipients) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_encrypt_result::invalid_recipients"
    );
}
#[test]
fn bindgen_test_layout__gpgme_recipient() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_recipient> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_recipient>(),
        48usize,
        "Size of _gpgme_recipient"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_recipient>(),
        8usize,
        "Alignment of _gpgme_recipient"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_recipient::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyid) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_recipient::keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._keyid) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_recipient::_keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        36usize,
        "Offset of field: _gpgme_recipient::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_recipient::status"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_decrypt_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_decrypt_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_decrypt_result>(),
        48usize,
        "Size of _gpgme_op_decrypt_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_decrypt_result>(),
        8usize,
        "Alignment of _gpgme_op_decrypt_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unsupported_algorithm) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_decrypt_result::unsupported_algorithm"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recipients) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_op_decrypt_result::recipients"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_op_decrypt_result::file_name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_key) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_op_decrypt_result::session_key"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).symkey_algo) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_op_decrypt_result::symkey_algo"
    );
}
#[test]
fn bindgen_test_layout__gpgme_new_signature() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_new_signature> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_new_signature>(),
        56usize,
        "Size of _gpgme_new_signature"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_new_signature>(),
        8usize,
        "Alignment of _gpgme_new_signature"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_new_signature::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_new_signature::type_"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_new_signature::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_algo) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_new_signature::hash_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._obsolete_class) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_new_signature::_obsolete_class"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_new_signature::timestamp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_new_signature::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_new_signature::class"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_class) as usize - ptr as usize },
        52usize,
        "Offset of field: _gpgme_new_signature::sig_class"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_sign_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_sign_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_sign_result>(),
        16usize,
        "Size of _gpgme_op_sign_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_sign_result>(),
        8usize,
        "Alignment of _gpgme_op_sign_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invalid_signers) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_sign_result::invalid_signers"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signatures) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_op_sign_result::signatures"
    );
}
#[test]
fn bindgen_test_layout__gpgme_signature() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_signature> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_signature>(),
        96usize,
        "Size of _gpgme_signature"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_signature>(),
        8usize,
        "Alignment of _gpgme_signature"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_signature::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).summary) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_signature::summary"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_signature::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_signature::status"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notations) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_signature::notations"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_signature::timestamp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exp_timestamp) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_signature::exp_timestamp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validity) as usize - ptr as usize },
        60usize,
        "Offset of field: _gpgme_signature::validity"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validity_reason) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_signature::validity_reason"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize },
        68usize,
        "Offset of field: _gpgme_signature::pubkey_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_algo) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_signature::hash_algo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pka_address) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_signature::pka_address"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        88usize,
        "Offset of field: _gpgme_signature::key"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_verify_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_verify_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_verify_result>(),
        24usize,
        "Size of _gpgme_op_verify_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_verify_result>(),
        8usize,
        "Alignment of _gpgme_op_verify_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signatures) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_verify_result::signatures"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_name) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_op_verify_result::file_name"
    );
}
#[test]
fn bindgen_test_layout__gpgme_import_status() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_import_status> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_import_status>(),
        24usize,
        "Size of _gpgme_import_status"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_import_status>(),
        8usize,
        "Alignment of _gpgme_import_status"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_import_status::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_import_status::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_import_status::result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        20usize,
        "Offset of field: _gpgme_import_status::status"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_import_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_import_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_import_result>(),
        72usize,
        "Size of _gpgme_op_import_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_import_result>(),
        8usize,
        "Alignment of _gpgme_op_import_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).considered) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_import_result::considered"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_user_id) as usize - ptr as usize },
        4usize,
        "Offset of field: _gpgme_op_import_result::no_user_id"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imported) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_op_import_result::imported"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imported_rsa) as usize - ptr as usize },
        12usize,
        "Offset of field: _gpgme_op_import_result::imported_rsa"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unchanged) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_op_import_result::unchanged"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_user_ids) as usize - ptr as usize },
        20usize,
        "Offset of field: _gpgme_op_import_result::new_user_ids"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_sub_keys) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_op_import_result::new_sub_keys"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_signatures) as usize - ptr as usize },
        28usize,
        "Offset of field: _gpgme_op_import_result::new_signatures"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_revocations) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_op_import_result::new_revocations"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secret_read) as usize - ptr as usize },
        36usize,
        "Offset of field: _gpgme_op_import_result::secret_read"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secret_imported) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_op_import_result::secret_imported"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secret_unchanged) as usize - ptr as usize },
        44usize,
        "Offset of field: _gpgme_op_import_result::secret_unchanged"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skipped_new_keys) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_op_import_result::skipped_new_keys"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).not_imported) as usize - ptr as usize },
        52usize,
        "Offset of field: _gpgme_op_import_result::not_imported"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imports) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_op_import_result::imports"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skipped_v3_keys) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_op_import_result::skipped_v3_keys"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_genkey_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_genkey_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_genkey_result>(),
        32usize,
        "Size of _gpgme_op_genkey_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_genkey_result>(),
        8usize,
        "Alignment of _gpgme_op_genkey_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpr) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_op_genkey_result::fpr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkey) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_op_genkey_result::pubkey"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seckey) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_op_genkey_result::seckey"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_keylist_result() {
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_keylist_result>(),
        4usize,
        "Size of _gpgme_op_keylist_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_keylist_result>(),
        4usize,
        "Alignment of _gpgme_op_keylist_result"
    );
}
#[test]
fn bindgen_test_layout__gpgme_trust_item() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_trust_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_trust_item>(),
        88usize,
        "Size of _gpgme_trust_item"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_trust_item>(),
        8usize,
        "Alignment of _gpgme_trust_item"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._refs) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_trust_item::_refs"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyid) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_trust_item::keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._keyid) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_trust_item::_keyid"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        "Offset of field: _gpgme_trust_item::type_"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        40usize,
        "Offset of field: _gpgme_trust_item::level"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner_trust) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_trust_item::owner_trust"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._owner_trust) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_trust_item::_owner_trust"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validity) as usize - ptr as usize },
        64usize,
        "Offset of field: _gpgme_trust_item::validity"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._validity) as usize - ptr as usize },
        72usize,
        "Offset of field: _gpgme_trust_item::_validity"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        "Offset of field: _gpgme_trust_item::name"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_vfs_mount_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_vfs_mount_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_vfs_mount_result>(),
        8usize,
        "Size of _gpgme_op_vfs_mount_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_vfs_mount_result>(),
        8usize,
        "Alignment of _gpgme_op_vfs_mount_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mount_dir) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_vfs_mount_result::mount_dir"
    );
}
#[test]
fn bindgen_test_layout_gpgme_conf_arg__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_conf_arg__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_conf_arg__bindgen_ty_1>(),
        8usize,
        "Size of gpgme_conf_arg__bindgen_ty_1"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_conf_arg__bindgen_ty_1>(),
        8usize,
        "Alignment of gpgme_conf_arg__bindgen_ty_1"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_arg__bindgen_ty_1::count"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_arg__bindgen_ty_1::uint32"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int32) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_arg__bindgen_ty_1::int32"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_arg__bindgen_ty_1::string"
    );
}
#[test]
fn bindgen_test_layout_gpgme_conf_arg() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_conf_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_conf_arg>(),
        24usize,
        "Size of gpgme_conf_arg"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_conf_arg>(),
        8usize,
        "Alignment of gpgme_conf_arg"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_arg::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_arg) as usize - ptr as usize },
        8usize,
        "Offset of field: gpgme_conf_arg::no_arg"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        "Offset of field: gpgme_conf_arg::value"
    );
}
#[test]
fn bindgen_test_layout_gpgme_conf_opt() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_conf_opt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_conf_opt>(),
        112usize,
        "Size of gpgme_conf_opt"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_conf_opt>(),
        8usize,
        "Alignment of gpgme_conf_opt"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_opt::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        "Offset of field: gpgme_conf_opt::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        "Offset of field: gpgme_conf_opt::flags"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        20usize,
        "Offset of field: gpgme_conf_opt::level"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        "Offset of field: gpgme_conf_opt::description"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        "Offset of field: gpgme_conf_opt::type_"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alt_type) as usize - ptr as usize },
        36usize,
        "Offset of field: gpgme_conf_opt::alt_type"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).argname) as usize - ptr as usize },
        40usize,
        "Offset of field: gpgme_conf_opt::argname"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        48usize,
        "Offset of field: gpgme_conf_opt::default_value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_description) as usize - ptr as usize },
        56usize,
        "Offset of field: gpgme_conf_opt::default_description"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_arg_value) as usize - ptr as usize },
        64usize,
        "Offset of field: gpgme_conf_opt::no_arg_value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_arg_description) as usize - ptr as usize },
        72usize,
        "Offset of field: gpgme_conf_opt::no_arg_description"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        80usize,
        "Offset of field: gpgme_conf_opt::value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change_value) as usize - ptr as usize },
        88usize,
        "Offset of field: gpgme_conf_opt::change_value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_value) as usize - ptr as usize },
        96usize,
        "Offset of field: gpgme_conf_opt::new_value"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        104usize,
        "Offset of field: gpgme_conf_opt::user_data"
    );
}
#[test]
fn bindgen_test_layout_gpgme_conf_comp() {
    const UNINIT: ::core::mem::MaybeUninit<gpgme_conf_comp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gpgme_conf_comp>(),
        48usize,
        "Size of gpgme_conf_comp"
    );
    assert_eq!(
        ::core::mem::align_of::<gpgme_conf_comp>(),
        8usize,
        "Alignment of gpgme_conf_comp"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: gpgme_conf_comp::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._last_opt_p) as usize - ptr as usize },
        8usize,
        "Offset of field: gpgme_conf_comp::_last_opt_p"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        "Offset of field: gpgme_conf_comp::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        "Offset of field: gpgme_conf_comp::description"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).program_name) as usize - ptr as usize },
        32usize,
        "Offset of field: gpgme_conf_comp::program_name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        40usize,
        "Offset of field: gpgme_conf_comp::options"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_query_swdb_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_query_swdb_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_query_swdb_result>(),
        64usize,
        "Size of _gpgme_op_query_swdb_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_query_swdb_result>(),
        8usize,
        "Alignment of _gpgme_op_query_swdb_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_query_swdb_result::next"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        "Offset of field: _gpgme_op_query_swdb_result::name"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iversion) as usize - ptr as usize },
        16usize,
        "Offset of field: _gpgme_op_query_swdb_result::iversion"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        24usize,
        "Offset of field: _gpgme_op_query_swdb_result::created"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retrieved) as usize - ptr as usize },
        32usize,
        "Offset of field: _gpgme_op_query_swdb_result::retrieved"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        48usize,
        "Offset of field: _gpgme_op_query_swdb_result::version"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reldate) as usize - ptr as usize },
        56usize,
        "Offset of field: _gpgme_op_query_swdb_result::reldate"
    );
}
#[test]
fn bindgen_test_layout__gpgme_op_assuan_result() {
    const UNINIT: ::core::mem::MaybeUninit<_gpgme_op_assuan_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_gpgme_op_assuan_result>(),
        4usize,
        "Size of _gpgme_op_assuan_result"
    );
    assert_eq!(
        ::core::mem::align_of::<_gpgme_op_assuan_result>(),
        4usize,
        "Alignment of _gpgme_op_assuan_result"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        0usize,
        "Offset of field: _gpgme_op_assuan_result::err"
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpg_err_source_t {
    GPG_ERR_SOURCE_UNKNOWN = 0,
    GPG_ERR_SOURCE_GCRYPT = 1,
    GPG_ERR_SOURCE_GPG = 2,
    GPG_ERR_SOURCE_GPGSM = 3,
    GPG_ERR_SOURCE_GPGAGENT = 4,
    GPG_ERR_SOURCE_PINENTRY = 5,
    GPG_ERR_SOURCE_SCD = 6,
    GPG_ERR_SOURCE_GPGME = 7,
    GPG_ERR_SOURCE_KEYBOX = 8,
    GPG_ERR_SOURCE_KSBA = 9,
    GPG_ERR_SOURCE_DIRMNGR = 10,
    GPG_ERR_SOURCE_GSTI = 11,
    GPG_ERR_SOURCE_GPA = 12,
    GPG_ERR_SOURCE_KLEO = 13,
    GPG_ERR_SOURCE_G13 = 14,
    GPG_ERR_SOURCE_ASSUAN = 15,
    GPG_ERR_SOURCE_TPM2D = 16,
    GPG_ERR_SOURCE_TLS = 17,
    GPG_ERR_SOURCE_TKD = 18,
    GPG_ERR_SOURCE_ANY = 31,
    GPG_ERR_SOURCE_USER_1 = 32,
    GPG_ERR_SOURCE_USER_2 = 33,
    GPG_ERR_SOURCE_USER_3 = 34,
    GPG_ERR_SOURCE_USER_4 = 35,
    GPG_ERR_SOURCE_DIM = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpg_err_code_t {
    GPG_ERR_NO_ERROR = 0,
    GPG_ERR_GENERAL = 1,
    GPG_ERR_UNKNOWN_PACKET = 2,
    GPG_ERR_UNKNOWN_VERSION = 3,
    GPG_ERR_PUBKEY_ALGO = 4,
    GPG_ERR_DIGEST_ALGO = 5,
    GPG_ERR_BAD_PUBKEY = 6,
    GPG_ERR_BAD_SECKEY = 7,
    GPG_ERR_BAD_SIGNATURE = 8,
    GPG_ERR_NO_PUBKEY = 9,
    GPG_ERR_CHECKSUM = 10,
    GPG_ERR_BAD_PASSPHRASE = 11,
    GPG_ERR_CIPHER_ALGO = 12,
    GPG_ERR_KEYRING_OPEN = 13,
    GPG_ERR_INV_PACKET = 14,
    GPG_ERR_INV_ARMOR = 15,
    GPG_ERR_NO_USER_ID = 16,
    GPG_ERR_NO_SECKEY = 17,
    GPG_ERR_WRONG_SECKEY = 18,
    GPG_ERR_BAD_KEY = 19,
    GPG_ERR_COMPR_ALGO = 20,
    GPG_ERR_NO_PRIME = 21,
    GPG_ERR_NO_ENCODING_METHOD = 22,
    GPG_ERR_NO_ENCRYPTION_SCHEME = 23,
    GPG_ERR_NO_SIGNATURE_SCHEME = 24,
    GPG_ERR_INV_ATTR = 25,
    GPG_ERR_NO_VALUE = 26,
    GPG_ERR_NOT_FOUND = 27,
    GPG_ERR_VALUE_NOT_FOUND = 28,
    GPG_ERR_SYNTAX = 29,
    GPG_ERR_BAD_MPI = 30,
    GPG_ERR_INV_PASSPHRASE = 31,
    GPG_ERR_SIG_CLASS = 32,
    GPG_ERR_RESOURCE_LIMIT = 33,
    GPG_ERR_INV_KEYRING = 34,
    GPG_ERR_TRUSTDB = 35,
    GPG_ERR_BAD_CERT = 36,
    GPG_ERR_INV_USER_ID = 37,
    GPG_ERR_UNEXPECTED = 38,
    GPG_ERR_TIME_CONFLICT = 39,
    GPG_ERR_KEYSERVER = 40,
    GPG_ERR_WRONG_PUBKEY_ALGO = 41,
    GPG_ERR_TRIBUTE_TO_D_A = 42,
    GPG_ERR_WEAK_KEY = 43,
    GPG_ERR_INV_KEYLEN = 44,
    GPG_ERR_INV_ARG = 45,
    GPG_ERR_BAD_URI = 46,
    GPG_ERR_INV_URI = 47,
    GPG_ERR_NETWORK = 48,
    GPG_ERR_UNKNOWN_HOST = 49,
    GPG_ERR_SELFTEST_FAILED = 50,
    GPG_ERR_NOT_ENCRYPTED = 51,
    GPG_ERR_NOT_PROCESSED = 52,
    GPG_ERR_UNUSABLE_PUBKEY = 53,
    GPG_ERR_UNUSABLE_SECKEY = 54,
    GPG_ERR_INV_VALUE = 55,
    GPG_ERR_BAD_CERT_CHAIN = 56,
    GPG_ERR_MISSING_CERT = 57,
    GPG_ERR_NO_DATA = 58,
    GPG_ERR_BUG = 59,
    GPG_ERR_NOT_SUPPORTED = 60,
    GPG_ERR_INV_OP = 61,
    GPG_ERR_TIMEOUT = 62,
    GPG_ERR_INTERNAL = 63,
    GPG_ERR_EOF_GCRYPT = 64,
    GPG_ERR_INV_OBJ = 65,
    GPG_ERR_TOO_SHORT = 66,
    GPG_ERR_TOO_LARGE = 67,
    GPG_ERR_NO_OBJ = 68,
    GPG_ERR_NOT_IMPLEMENTED = 69,
    GPG_ERR_CONFLICT = 70,
    GPG_ERR_INV_CIPHER_MODE = 71,
    GPG_ERR_INV_FLAG = 72,
    GPG_ERR_INV_HANDLE = 73,
    GPG_ERR_TRUNCATED = 74,
    GPG_ERR_INCOMPLETE_LINE = 75,
    GPG_ERR_INV_RESPONSE = 76,
    GPG_ERR_NO_AGENT = 77,
    GPG_ERR_AGENT = 78,
    GPG_ERR_INV_DATA = 79,
    GPG_ERR_ASSUAN_SERVER_FAULT = 80,
    GPG_ERR_ASSUAN = 81,
    GPG_ERR_INV_SESSION_KEY = 82,
    GPG_ERR_INV_SEXP = 83,
    GPG_ERR_UNSUPPORTED_ALGORITHM = 84,
    GPG_ERR_NO_PIN_ENTRY = 85,
    GPG_ERR_PIN_ENTRY = 86,
    GPG_ERR_BAD_PIN = 87,
    GPG_ERR_INV_NAME = 88,
    GPG_ERR_BAD_DATA = 89,
    GPG_ERR_INV_PARAMETER = 90,
    GPG_ERR_WRONG_CARD = 91,
    GPG_ERR_NO_DIRMNGR = 92,
    GPG_ERR_DIRMNGR = 93,
    GPG_ERR_CERT_REVOKED = 94,
    GPG_ERR_NO_CRL_KNOWN = 95,
    GPG_ERR_CRL_TOO_OLD = 96,
    GPG_ERR_LINE_TOO_LONG = 97,
    GPG_ERR_NOT_TRUSTED = 98,
    GPG_ERR_CANCELED = 99,
    GPG_ERR_BAD_CA_CERT = 100,
    GPG_ERR_CERT_EXPIRED = 101,
    GPG_ERR_CERT_TOO_YOUNG = 102,
    GPG_ERR_UNSUPPORTED_CERT = 103,
    GPG_ERR_UNKNOWN_SEXP = 104,
    GPG_ERR_UNSUPPORTED_PROTECTION = 105,
    GPG_ERR_CORRUPTED_PROTECTION = 106,
    GPG_ERR_AMBIGUOUS_NAME = 107,
    GPG_ERR_CARD = 108,
    GPG_ERR_CARD_RESET = 109,
    GPG_ERR_CARD_REMOVED = 110,
    GPG_ERR_INV_CARD = 111,
    GPG_ERR_CARD_NOT_PRESENT = 112,
    GPG_ERR_NO_PKCS15_APP = 113,
    GPG_ERR_NOT_CONFIRMED = 114,
    GPG_ERR_CONFIGURATION = 115,
    GPG_ERR_NO_POLICY_MATCH = 116,
    GPG_ERR_INV_INDEX = 117,
    GPG_ERR_INV_ID = 118,
    GPG_ERR_NO_SCDAEMON = 119,
    GPG_ERR_SCDAEMON = 120,
    GPG_ERR_UNSUPPORTED_PROTOCOL = 121,
    GPG_ERR_BAD_PIN_METHOD = 122,
    GPG_ERR_CARD_NOT_INITIALIZED = 123,
    GPG_ERR_UNSUPPORTED_OPERATION = 124,
    GPG_ERR_WRONG_KEY_USAGE = 125,
    GPG_ERR_NOTHING_FOUND = 126,
    GPG_ERR_WRONG_BLOB_TYPE = 127,
    GPG_ERR_MISSING_VALUE = 128,
    GPG_ERR_HARDWARE = 129,
    GPG_ERR_PIN_BLOCKED = 130,
    GPG_ERR_USE_CONDITIONS = 131,
    GPG_ERR_PIN_NOT_SYNCED = 132,
    GPG_ERR_INV_CRL = 133,
    GPG_ERR_BAD_BER = 134,
    GPG_ERR_INV_BER = 135,
    GPG_ERR_ELEMENT_NOT_FOUND = 136,
    GPG_ERR_IDENTIFIER_NOT_FOUND = 137,
    GPG_ERR_INV_TAG = 138,
    GPG_ERR_INV_LENGTH = 139,
    GPG_ERR_INV_KEYINFO = 140,
    GPG_ERR_UNEXPECTED_TAG = 141,
    GPG_ERR_NOT_DER_ENCODED = 142,
    GPG_ERR_NO_CMS_OBJ = 143,
    GPG_ERR_INV_CMS_OBJ = 144,
    GPG_ERR_UNKNOWN_CMS_OBJ = 145,
    GPG_ERR_UNSUPPORTED_CMS_OBJ = 146,
    GPG_ERR_UNSUPPORTED_ENCODING = 147,
    GPG_ERR_UNSUPPORTED_CMS_VERSION = 148,
    GPG_ERR_UNKNOWN_ALGORITHM = 149,
    GPG_ERR_INV_ENGINE = 150,
    GPG_ERR_PUBKEY_NOT_TRUSTED = 151,
    GPG_ERR_DECRYPT_FAILED = 152,
    GPG_ERR_KEY_EXPIRED = 153,
    GPG_ERR_SIG_EXPIRED = 154,
    GPG_ERR_ENCODING_PROBLEM = 155,
    GPG_ERR_INV_STATE = 156,
    GPG_ERR_DUP_VALUE = 157,
    GPG_ERR_MISSING_ACTION = 158,
    GPG_ERR_MODULE_NOT_FOUND = 159,
    GPG_ERR_INV_OID_STRING = 160,
    GPG_ERR_INV_TIME = 161,
    GPG_ERR_INV_CRL_OBJ = 162,
    GPG_ERR_UNSUPPORTED_CRL_VERSION = 163,
    GPG_ERR_INV_CERT_OBJ = 164,
    GPG_ERR_UNKNOWN_NAME = 165,
    GPG_ERR_LOCALE_PROBLEM = 166,
    GPG_ERR_NOT_LOCKED = 167,
    GPG_ERR_PROTOCOL_VIOLATION = 168,
    GPG_ERR_INV_MAC = 169,
    GPG_ERR_INV_REQUEST = 170,
    GPG_ERR_UNKNOWN_EXTN = 171,
    GPG_ERR_UNKNOWN_CRIT_EXTN = 172,
    GPG_ERR_LOCKED = 173,
    GPG_ERR_UNKNOWN_OPTION = 174,
    GPG_ERR_UNKNOWN_COMMAND = 175,
    GPG_ERR_NOT_OPERATIONAL = 176,
    GPG_ERR_NO_PASSPHRASE = 177,
    GPG_ERR_NO_PIN = 178,
    GPG_ERR_NOT_ENABLED = 179,
    GPG_ERR_NO_ENGINE = 180,
    GPG_ERR_MISSING_KEY = 181,
    GPG_ERR_TOO_MANY = 182,
    GPG_ERR_LIMIT_REACHED = 183,
    GPG_ERR_NOT_INITIALIZED = 184,
    GPG_ERR_MISSING_ISSUER_CERT = 185,
    GPG_ERR_NO_KEYSERVER = 186,
    GPG_ERR_INV_CURVE = 187,
    GPG_ERR_UNKNOWN_CURVE = 188,
    GPG_ERR_DUP_KEY = 189,
    GPG_ERR_AMBIGUOUS = 190,
    GPG_ERR_NO_CRYPT_CTX = 191,
    GPG_ERR_WRONG_CRYPT_CTX = 192,
    GPG_ERR_BAD_CRYPT_CTX = 193,
    GPG_ERR_CRYPT_CTX_CONFLICT = 194,
    GPG_ERR_BROKEN_PUBKEY = 195,
    GPG_ERR_BROKEN_SECKEY = 196,
    GPG_ERR_MAC_ALGO = 197,
    GPG_ERR_FULLY_CANCELED = 198,
    GPG_ERR_UNFINISHED = 199,
    GPG_ERR_BUFFER_TOO_SHORT = 200,
    GPG_ERR_SEXP_INV_LEN_SPEC = 201,
    GPG_ERR_SEXP_STRING_TOO_LONG = 202,
    GPG_ERR_SEXP_UNMATCHED_PAREN = 203,
    GPG_ERR_SEXP_NOT_CANONICAL = 204,
    GPG_ERR_SEXP_BAD_CHARACTER = 205,
    GPG_ERR_SEXP_BAD_QUOTATION = 206,
    GPG_ERR_SEXP_ZERO_PREFIX = 207,
    GPG_ERR_SEXP_NESTED_DH = 208,
    GPG_ERR_SEXP_UNMATCHED_DH = 209,
    GPG_ERR_SEXP_UNEXPECTED_PUNC = 210,
    GPG_ERR_SEXP_BAD_HEX_CHAR = 211,
    GPG_ERR_SEXP_ODD_HEX_NUMBERS = 212,
    GPG_ERR_SEXP_BAD_OCT_CHAR = 213,
    GPG_ERR_SUBKEYS_EXP_OR_REV = 217,
    GPG_ERR_DB_CORRUPTED = 218,
    GPG_ERR_SERVER_FAILED = 219,
    GPG_ERR_NO_NAME = 220,
    GPG_ERR_NO_KEY = 221,
    GPG_ERR_LEGACY_KEY = 222,
    GPG_ERR_REQUEST_TOO_SHORT = 223,
    GPG_ERR_REQUEST_TOO_LONG = 224,
    GPG_ERR_OBJ_TERM_STATE = 225,
    GPG_ERR_NO_CERT_CHAIN = 226,
    GPG_ERR_CERT_TOO_LARGE = 227,
    GPG_ERR_INV_RECORD = 228,
    GPG_ERR_BAD_MAC = 229,
    GPG_ERR_UNEXPECTED_MSG = 230,
    GPG_ERR_COMPR_FAILED = 231,
    GPG_ERR_WOULD_WRAP = 232,
    GPG_ERR_FATAL_ALERT = 233,
    GPG_ERR_NO_CIPHER = 234,
    GPG_ERR_MISSING_CLIENT_CERT = 235,
    GPG_ERR_CLOSE_NOTIFY = 236,
    GPG_ERR_TICKET_EXPIRED = 237,
    GPG_ERR_BAD_TICKET = 238,
    GPG_ERR_UNKNOWN_IDENTITY = 239,
    GPG_ERR_BAD_HS_CERT = 240,
    GPG_ERR_BAD_HS_CERT_REQ = 241,
    GPG_ERR_BAD_HS_CERT_VER = 242,
    GPG_ERR_BAD_HS_CHANGE_CIPHER = 243,
    GPG_ERR_BAD_HS_CLIENT_HELLO = 244,
    GPG_ERR_BAD_HS_SERVER_HELLO = 245,
    GPG_ERR_BAD_HS_SERVER_HELLO_DONE = 246,
    GPG_ERR_BAD_HS_FINISHED = 247,
    GPG_ERR_BAD_HS_SERVER_KEX = 248,
    GPG_ERR_BAD_HS_CLIENT_KEX = 249,
    GPG_ERR_BOGUS_STRING = 250,
    GPG_ERR_FORBIDDEN = 251,
    GPG_ERR_KEY_DISABLED = 252,
    GPG_ERR_KEY_ON_CARD = 253,
    GPG_ERR_INV_LOCK_OBJ = 254,
    GPG_ERR_TRUE = 255,
    GPG_ERR_FALSE = 256,
    GPG_ERR_ASS_GENERAL = 257,
    GPG_ERR_ASS_ACCEPT_FAILED = 258,
    GPG_ERR_ASS_CONNECT_FAILED = 259,
    GPG_ERR_ASS_INV_RESPONSE = 260,
    GPG_ERR_ASS_INV_VALUE = 261,
    GPG_ERR_ASS_INCOMPLETE_LINE = 262,
    GPG_ERR_ASS_LINE_TOO_LONG = 263,
    GPG_ERR_ASS_NESTED_COMMANDS = 264,
    GPG_ERR_ASS_NO_DATA_CB = 265,
    GPG_ERR_ASS_NO_INQUIRE_CB = 266,
    GPG_ERR_ASS_NOT_A_SERVER = 267,
    GPG_ERR_ASS_NOT_A_CLIENT = 268,
    GPG_ERR_ASS_SERVER_START = 269,
    GPG_ERR_ASS_READ_ERROR = 270,
    GPG_ERR_ASS_WRITE_ERROR = 271,
    GPG_ERR_ASS_TOO_MUCH_DATA = 273,
    GPG_ERR_ASS_UNEXPECTED_CMD = 274,
    GPG_ERR_ASS_UNKNOWN_CMD = 275,
    GPG_ERR_ASS_SYNTAX = 276,
    GPG_ERR_ASS_CANCELED = 277,
    GPG_ERR_ASS_NO_INPUT = 278,
    GPG_ERR_ASS_NO_OUTPUT = 279,
    GPG_ERR_ASS_PARAMETER = 280,
    GPG_ERR_ASS_UNKNOWN_INQUIRE = 281,
    GPG_ERR_ENGINE_TOO_OLD = 300,
    GPG_ERR_WINDOW_TOO_SMALL = 301,
    GPG_ERR_WINDOW_TOO_LARGE = 302,
    GPG_ERR_MISSING_ENVVAR = 303,
    GPG_ERR_USER_ID_EXISTS = 304,
    GPG_ERR_NAME_EXISTS = 305,
    GPG_ERR_DUP_NAME = 306,
    GPG_ERR_TOO_YOUNG = 307,
    GPG_ERR_TOO_OLD = 308,
    GPG_ERR_UNKNOWN_FLAG = 309,
    GPG_ERR_INV_ORDER = 310,
    GPG_ERR_ALREADY_FETCHED = 311,
    GPG_ERR_TRY_LATER = 312,
    GPG_ERR_WRONG_NAME = 313,
    GPG_ERR_NO_AUTH = 314,
    GPG_ERR_BAD_AUTH = 315,
    GPG_ERR_NO_KEYBOXD = 316,
    GPG_ERR_KEYBOXD = 317,
    GPG_ERR_NO_SERVICE = 318,
    GPG_ERR_SERVICE = 319,
    GPG_ERR_BAD_PUK = 320,
    GPG_ERR_NO_RESET_CODE = 321,
    GPG_ERR_BAD_RESET_CODE = 322,
    GPG_ERR_SYSTEM_BUG = 666,
    GPG_ERR_DNS_UNKNOWN = 711,
    GPG_ERR_DNS_SECTION = 712,
    GPG_ERR_DNS_ADDRESS = 713,
    GPG_ERR_DNS_NO_QUERY = 714,
    GPG_ERR_DNS_NO_ANSWER = 715,
    GPG_ERR_DNS_CLOSED = 716,
    GPG_ERR_DNS_VERIFY = 717,
    GPG_ERR_DNS_TIMEOUT = 718,
    GPG_ERR_LDAP_GENERAL = 721,
    GPG_ERR_LDAP_ATTR_GENERAL = 722,
    GPG_ERR_LDAP_NAME_GENERAL = 723,
    GPG_ERR_LDAP_SECURITY_GENERAL = 724,
    GPG_ERR_LDAP_SERVICE_GENERAL = 725,
    GPG_ERR_LDAP_UPDATE_GENERAL = 726,
    GPG_ERR_LDAP_E_GENERAL = 727,
    GPG_ERR_LDAP_X_GENERAL = 728,
    GPG_ERR_LDAP_OTHER_GENERAL = 729,
    GPG_ERR_LDAP_X_CONNECTING = 750,
    GPG_ERR_LDAP_REFERRAL_LIMIT = 751,
    GPG_ERR_LDAP_CLIENT_LOOP = 752,
    GPG_ERR_LDAP_NO_RESULTS = 754,
    GPG_ERR_LDAP_CONTROL_NOT_FOUND = 755,
    GPG_ERR_LDAP_NOT_SUPPORTED = 756,
    GPG_ERR_LDAP_CONNECT = 757,
    GPG_ERR_LDAP_NO_MEMORY = 758,
    GPG_ERR_LDAP_PARAM = 759,
    GPG_ERR_LDAP_USER_CANCELLED = 760,
    GPG_ERR_LDAP_FILTER = 761,
    GPG_ERR_LDAP_AUTH_UNKNOWN = 762,
    GPG_ERR_LDAP_TIMEOUT = 763,
    GPG_ERR_LDAP_DECODING = 764,
    GPG_ERR_LDAP_ENCODING = 765,
    GPG_ERR_LDAP_LOCAL = 766,
    GPG_ERR_LDAP_SERVER_DOWN = 767,
    GPG_ERR_LDAP_SUCCESS = 768,
    GPG_ERR_LDAP_OPERATIONS = 769,
    GPG_ERR_LDAP_PROTOCOL = 770,
    GPG_ERR_LDAP_TIMELIMIT = 771,
    GPG_ERR_LDAP_SIZELIMIT = 772,
    GPG_ERR_LDAP_COMPARE_FALSE = 773,
    GPG_ERR_LDAP_COMPARE_TRUE = 774,
    GPG_ERR_LDAP_UNSUPPORTED_AUTH = 775,
    GPG_ERR_LDAP_STRONG_AUTH_RQRD = 776,
    GPG_ERR_LDAP_PARTIAL_RESULTS = 777,
    GPG_ERR_LDAP_REFERRAL = 778,
    GPG_ERR_LDAP_ADMINLIMIT = 779,
    GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN = 780,
    GPG_ERR_LDAP_CONFIDENT_RQRD = 781,
    GPG_ERR_LDAP_SASL_BIND_INPROG = 782,
    GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE = 784,
    GPG_ERR_LDAP_UNDEFINED_TYPE = 785,
    GPG_ERR_LDAP_BAD_MATCHING = 786,
    GPG_ERR_LDAP_CONST_VIOLATION = 787,
    GPG_ERR_LDAP_TYPE_VALUE_EXISTS = 788,
    GPG_ERR_LDAP_INV_SYNTAX = 789,
    GPG_ERR_LDAP_NO_SUCH_OBJ = 800,
    GPG_ERR_LDAP_ALIAS_PROBLEM = 801,
    GPG_ERR_LDAP_INV_DN_SYNTAX = 802,
    GPG_ERR_LDAP_IS_LEAF = 803,
    GPG_ERR_LDAP_ALIAS_DEREF = 804,
    GPG_ERR_LDAP_X_PROXY_AUTH_FAIL = 815,
    GPG_ERR_LDAP_BAD_AUTH = 816,
    GPG_ERR_LDAP_INV_CREDENTIALS = 817,
    GPG_ERR_LDAP_INSUFFICIENT_ACC = 818,
    GPG_ERR_LDAP_BUSY = 819,
    GPG_ERR_LDAP_UNAVAILABLE = 820,
    GPG_ERR_LDAP_UNWILL_TO_PERFORM = 821,
    GPG_ERR_LDAP_LOOP_DETECT = 822,
    GPG_ERR_LDAP_NAMING_VIOLATION = 832,
    GPG_ERR_LDAP_OBJ_CLS_VIOLATION = 833,
    GPG_ERR_LDAP_NOT_ALLOW_NONLEAF = 834,
    GPG_ERR_LDAP_NOT_ALLOW_ON_RDN = 835,
    GPG_ERR_LDAP_ALREADY_EXISTS = 836,
    GPG_ERR_LDAP_NO_OBJ_CLASS_MODS = 837,
    GPG_ERR_LDAP_RESULTS_TOO_LARGE = 838,
    GPG_ERR_LDAP_AFFECTS_MULT_DSAS = 839,
    GPG_ERR_LDAP_VLV = 844,
    GPG_ERR_LDAP_OTHER = 848,
    GPG_ERR_LDAP_CUP_RESOURCE_LIMIT = 881,
    GPG_ERR_LDAP_CUP_SEC_VIOLATION = 882,
    GPG_ERR_LDAP_CUP_INV_DATA = 883,
    GPG_ERR_LDAP_CUP_UNSUP_SCHEME = 884,
    GPG_ERR_LDAP_CUP_RELOAD = 885,
    GPG_ERR_LDAP_CANCELLED = 886,
    GPG_ERR_LDAP_NO_SUCH_OPERATION = 887,
    GPG_ERR_LDAP_TOO_LATE = 888,
    GPG_ERR_LDAP_CANNOT_CANCEL = 889,
    GPG_ERR_LDAP_ASSERTION_FAILED = 890,
    GPG_ERR_LDAP_PROX_AUTH_DENIED = 891,
    GPG_ERR_USER_1 = 1024,
    GPG_ERR_USER_2 = 1025,
    GPG_ERR_USER_3 = 1026,
    GPG_ERR_USER_4 = 1027,
    GPG_ERR_USER_5 = 1028,
    GPG_ERR_USER_6 = 1029,
    GPG_ERR_USER_7 = 1030,
    GPG_ERR_USER_8 = 1031,
    GPG_ERR_USER_9 = 1032,
    GPG_ERR_USER_10 = 1033,
    GPG_ERR_USER_11 = 1034,
    GPG_ERR_USER_12 = 1035,
    GPG_ERR_USER_13 = 1036,
    GPG_ERR_USER_14 = 1037,
    GPG_ERR_USER_15 = 1038,
    GPG_ERR_USER_16 = 1039,
    GPG_ERR_SQL_OK = 1500,
    GPG_ERR_SQL_ERROR = 1501,
    GPG_ERR_SQL_INTERNAL = 1502,
    GPG_ERR_SQL_PERM = 1503,
    GPG_ERR_SQL_ABORT = 1504,
    GPG_ERR_SQL_BUSY = 1505,
    GPG_ERR_SQL_LOCKED = 1506,
    GPG_ERR_SQL_NOMEM = 1507,
    GPG_ERR_SQL_READONLY = 1508,
    GPG_ERR_SQL_INTERRUPT = 1509,
    GPG_ERR_SQL_IOERR = 1510,
    GPG_ERR_SQL_CORRUPT = 1511,
    GPG_ERR_SQL_NOTFOUND = 1512,
    GPG_ERR_SQL_FULL = 1513,
    GPG_ERR_SQL_CANTOPEN = 1514,
    GPG_ERR_SQL_PROTOCOL = 1515,
    GPG_ERR_SQL_EMPTY = 1516,
    GPG_ERR_SQL_SCHEMA = 1517,
    GPG_ERR_SQL_TOOBIG = 1518,
    GPG_ERR_SQL_CONSTRAINT = 1519,
    GPG_ERR_SQL_MISMATCH = 1520,
    GPG_ERR_SQL_MISUSE = 1521,
    GPG_ERR_SQL_NOLFS = 1522,
    GPG_ERR_SQL_AUTH = 1523,
    GPG_ERR_SQL_FORMAT = 1524,
    GPG_ERR_SQL_RANGE = 1525,
    GPG_ERR_SQL_NOTADB = 1526,
    GPG_ERR_SQL_NOTICE = 1527,
    GPG_ERR_SQL_WARNING = 1528,
    GPG_ERR_SQL_ROW = 1600,
    GPG_ERR_SQL_DONE = 1601,
    GPG_ERR_MISSING_ERRNO = 16381,
    GPG_ERR_UNKNOWN_ERRNO = 16382,
    GPG_ERR_EOF = 16383,
    GPG_ERR_E2BIG = 32768,
    GPG_ERR_EACCES = 32769,
    GPG_ERR_EADDRINUSE = 32770,
    GPG_ERR_EADDRNOTAVAIL = 32771,
    GPG_ERR_EADV = 32772,
    GPG_ERR_EAFNOSUPPORT = 32773,
    GPG_ERR_EAGAIN = 32774,
    GPG_ERR_EALREADY = 32775,
    GPG_ERR_EAUTH = 32776,
    GPG_ERR_EBACKGROUND = 32777,
    GPG_ERR_EBADE = 32778,
    GPG_ERR_EBADF = 32779,
    GPG_ERR_EBADFD = 32780,
    GPG_ERR_EBADMSG = 32781,
    GPG_ERR_EBADR = 32782,
    GPG_ERR_EBADRPC = 32783,
    GPG_ERR_EBADRQC = 32784,
    GPG_ERR_EBADSLT = 32785,
    GPG_ERR_EBFONT = 32786,
    GPG_ERR_EBUSY = 32787,
    GPG_ERR_ECANCELED = 32788,
    GPG_ERR_ECHILD = 32789,
    GPG_ERR_ECHRNG = 32790,
    GPG_ERR_ECOMM = 32791,
    GPG_ERR_ECONNABORTED = 32792,
    GPG_ERR_ECONNREFUSED = 32793,
    GPG_ERR_ECONNRESET = 32794,
    GPG_ERR_ED = 32795,
    GPG_ERR_EDEADLK = 32796,
    GPG_ERR_EDEADLOCK = 32797,
    GPG_ERR_EDESTADDRREQ = 32798,
    GPG_ERR_EDIED = 32799,
    GPG_ERR_EDOM = 32800,
    GPG_ERR_EDOTDOT = 32801,
    GPG_ERR_EDQUOT = 32802,
    GPG_ERR_EEXIST = 32803,
    GPG_ERR_EFAULT = 32804,
    GPG_ERR_EFBIG = 32805,
    GPG_ERR_EFTYPE = 32806,
    GPG_ERR_EGRATUITOUS = 32807,
    GPG_ERR_EGREGIOUS = 32808,
    GPG_ERR_EHOSTDOWN = 32809,
    GPG_ERR_EHOSTUNREACH = 32810,
    GPG_ERR_EIDRM = 32811,
    GPG_ERR_EIEIO = 32812,
    GPG_ERR_EILSEQ = 32813,
    GPG_ERR_EINPROGRESS = 32814,
    GPG_ERR_EINTR = 32815,
    GPG_ERR_EINVAL = 32816,
    GPG_ERR_EIO = 32817,
    GPG_ERR_EISCONN = 32818,
    GPG_ERR_EISDIR = 32819,
    GPG_ERR_EISNAM = 32820,
    GPG_ERR_EL2HLT = 32821,
    GPG_ERR_EL2NSYNC = 32822,
    GPG_ERR_EL3HLT = 32823,
    GPG_ERR_EL3RST = 32824,
    GPG_ERR_ELIBACC = 32825,
    GPG_ERR_ELIBBAD = 32826,
    GPG_ERR_ELIBEXEC = 32827,
    GPG_ERR_ELIBMAX = 32828,
    GPG_ERR_ELIBSCN = 32829,
    GPG_ERR_ELNRNG = 32830,
    GPG_ERR_ELOOP = 32831,
    GPG_ERR_EMEDIUMTYPE = 32832,
    GPG_ERR_EMFILE = 32833,
    GPG_ERR_EMLINK = 32834,
    GPG_ERR_EMSGSIZE = 32835,
    GPG_ERR_EMULTIHOP = 32836,
    GPG_ERR_ENAMETOOLONG = 32837,
    GPG_ERR_ENAVAIL = 32838,
    GPG_ERR_ENEEDAUTH = 32839,
    GPG_ERR_ENETDOWN = 32840,
    GPG_ERR_ENETRESET = 32841,
    GPG_ERR_ENETUNREACH = 32842,
    GPG_ERR_ENFILE = 32843,
    GPG_ERR_ENOANO = 32844,
    GPG_ERR_ENOBUFS = 32845,
    GPG_ERR_ENOCSI = 32846,
    GPG_ERR_ENODATA = 32847,
    GPG_ERR_ENODEV = 32848,
    GPG_ERR_ENOENT = 32849,
    GPG_ERR_ENOEXEC = 32850,
    GPG_ERR_ENOLCK = 32851,
    GPG_ERR_ENOLINK = 32852,
    GPG_ERR_ENOMEDIUM = 32853,
    GPG_ERR_ENOMEM = 32854,
    GPG_ERR_ENOMSG = 32855,
    GPG_ERR_ENONET = 32856,
    GPG_ERR_ENOPKG = 32857,
    GPG_ERR_ENOPROTOOPT = 32858,
    GPG_ERR_ENOSPC = 32859,
    GPG_ERR_ENOSR = 32860,
    GPG_ERR_ENOSTR = 32861,
    GPG_ERR_ENOSYS = 32862,
    GPG_ERR_ENOTBLK = 32863,
    GPG_ERR_ENOTCONN = 32864,
    GPG_ERR_ENOTDIR = 32865,
    GPG_ERR_ENOTEMPTY = 32866,
    GPG_ERR_ENOTNAM = 32867,
    GPG_ERR_ENOTSOCK = 32868,
    GPG_ERR_ENOTSUP = 32869,
    GPG_ERR_ENOTTY = 32870,
    GPG_ERR_ENOTUNIQ = 32871,
    GPG_ERR_ENXIO = 32872,
    GPG_ERR_EOPNOTSUPP = 32873,
    GPG_ERR_EOVERFLOW = 32874,
    GPG_ERR_EPERM = 32875,
    GPG_ERR_EPFNOSUPPORT = 32876,
    GPG_ERR_EPIPE = 32877,
    GPG_ERR_EPROCLIM = 32878,
    GPG_ERR_EPROCUNAVAIL = 32879,
    GPG_ERR_EPROGMISMATCH = 32880,
    GPG_ERR_EPROGUNAVAIL = 32881,
    GPG_ERR_EPROTO = 32882,
    GPG_ERR_EPROTONOSUPPORT = 32883,
    GPG_ERR_EPROTOTYPE = 32884,
    GPG_ERR_ERANGE = 32885,
    GPG_ERR_EREMCHG = 32886,
    GPG_ERR_EREMOTE = 32887,
    GPG_ERR_EREMOTEIO = 32888,
    GPG_ERR_ERESTART = 32889,
    GPG_ERR_EROFS = 32890,
    GPG_ERR_ERPCMISMATCH = 32891,
    GPG_ERR_ESHUTDOWN = 32892,
    GPG_ERR_ESOCKTNOSUPPORT = 32893,
    GPG_ERR_ESPIPE = 32894,
    GPG_ERR_ESRCH = 32895,
    GPG_ERR_ESRMNT = 32896,
    GPG_ERR_ESTALE = 32897,
    GPG_ERR_ESTRPIPE = 32898,
    GPG_ERR_ETIME = 32899,
    GPG_ERR_ETIMEDOUT = 32900,
    GPG_ERR_ETOOMANYREFS = 32901,
    GPG_ERR_ETXTBSY = 32902,
    GPG_ERR_EUCLEAN = 32903,
    GPG_ERR_EUNATCH = 32904,
    GPG_ERR_EUSERS = 32905,
    GPG_ERR_EWOULDBLOCK = 32906,
    GPG_ERR_EXDEV = 32907,
    GPG_ERR_EXFULL = 32908,
    GPG_ERR_CODE_DIM = 65536,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_data_encoding_t {
    GPGME_DATA_ENCODING_NONE = 0,
    GPGME_DATA_ENCODING_BINARY = 1,
    GPGME_DATA_ENCODING_BASE64 = 2,
    GPGME_DATA_ENCODING_ARMOR = 3,
    GPGME_DATA_ENCODING_URL = 4,
    GPGME_DATA_ENCODING_URLESC = 5,
    GPGME_DATA_ENCODING_URL0 = 6,
    GPGME_DATA_ENCODING_MIME = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_data_type_t {
    GPGME_DATA_TYPE_INVALID = 0,
    GPGME_DATA_TYPE_UNKNOWN = 1,
    GPGME_DATA_TYPE_PGP_SIGNED = 16,
    GPGME_DATA_TYPE_PGP_ENCRYPTED = 17,
    GPGME_DATA_TYPE_PGP_OTHER = 18,
    GPGME_DATA_TYPE_PGP_KEY = 19,
    GPGME_DATA_TYPE_PGP_SIGNATURE = 24,
    GPGME_DATA_TYPE_CMS_SIGNED = 32,
    GPGME_DATA_TYPE_CMS_ENCRYPTED = 33,
    GPGME_DATA_TYPE_CMS_OTHER = 34,
    GPGME_DATA_TYPE_X509_CERT = 35,
    GPGME_DATA_TYPE_PKCS12 = 36,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_pubkey_algo_t {
    GPGME_PK_RSA = 1,
    GPGME_PK_RSA_E = 2,
    GPGME_PK_RSA_S = 3,
    GPGME_PK_ELG_E = 16,
    GPGME_PK_DSA = 17,
    GPGME_PK_ECC = 18,
    GPGME_PK_ELG = 20,
    GPGME_PK_ECDSA = 301,
    GPGME_PK_ECDH = 302,
    GPGME_PK_EDDSA = 303,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_hash_algo_t {
    GPGME_MD_NONE = 0,
    GPGME_MD_MD5 = 1,
    GPGME_MD_SHA1 = 2,
    GPGME_MD_RMD160 = 3,
    GPGME_MD_MD2 = 5,
    GPGME_MD_TIGER = 6,
    GPGME_MD_HAVAL = 7,
    GPGME_MD_SHA256 = 8,
    GPGME_MD_SHA384 = 9,
    GPGME_MD_SHA512 = 10,
    GPGME_MD_SHA224 = 11,
    GPGME_MD_MD4 = 301,
    GPGME_MD_CRC32 = 302,
    GPGME_MD_CRC32_RFC1510 = 303,
    GPGME_MD_CRC24_RFC2440 = 304,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_sig_mode_t {
    GPGME_SIG_MODE_NORMAL = 0,
    GPGME_SIG_MODE_DETACH = 1,
    GPGME_SIG_MODE_CLEAR = 2,
    GPGME_SIG_MODE_ARCHIVE = 4,
    GPGME_SIG_MODE_FILE = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_validity_t {
    GPGME_VALIDITY_UNKNOWN = 0,
    GPGME_VALIDITY_UNDEFINED = 1,
    GPGME_VALIDITY_NEVER = 2,
    GPGME_VALIDITY_MARGINAL = 3,
    GPGME_VALIDITY_FULL = 4,
    GPGME_VALIDITY_ULTIMATE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_tofu_policy_t {
    GPGME_TOFU_POLICY_NONE = 0,
    GPGME_TOFU_POLICY_AUTO = 1,
    GPGME_TOFU_POLICY_GOOD = 2,
    GPGME_TOFU_POLICY_UNKNOWN = 3,
    GPGME_TOFU_POLICY_BAD = 4,
    GPGME_TOFU_POLICY_ASK = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_keyorg_t {
    GPGME_KEYORG_UNKNOWN = 0,
    GPGME_KEYORG_KS = 1,
    GPGME_KEYORG_DANE = 3,
    GPGME_KEYORG_WKD = 4,
    GPGME_KEYORG_URL = 5,
    GPGME_KEYORG_FILE = 6,
    GPGME_KEYORG_SELF = 7,
    GPGME_KEYORG_OTHER = 31,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_protocol_t {
    GPGME_PROTOCOL_OpenPGP = 0,
    GPGME_PROTOCOL_CMS = 1,
    GPGME_PROTOCOL_GPGCONF = 2,
    GPGME_PROTOCOL_ASSUAN = 3,
    GPGME_PROTOCOL_G13 = 4,
    GPGME_PROTOCOL_UISERVER = 5,
    GPGME_PROTOCOL_SPAWN = 6,
    GPGME_PROTOCOL_DEFAULT = 254,
    GPGME_PROTOCOL_UNKNOWN = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_pinentry_mode_t {
    GPGME_PINENTRY_MODE_DEFAULT = 0,
    GPGME_PINENTRY_MODE_ASK = 1,
    GPGME_PINENTRY_MODE_CANCEL = 2,
    GPGME_PINENTRY_MODE_ERROR = 3,
    GPGME_PINENTRY_MODE_LOOPBACK = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_event_io_t {
    GPGME_EVENT_START = 0,
    GPGME_EVENT_DONE = 1,
    GPGME_EVENT_NEXT_KEY = 2,
    GPGME_EVENT_NEXT_TRUSTITEM = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_conf_level_t {
    GPGME_CONF_BASIC = 0,
    GPGME_CONF_ADVANCED = 1,
    GPGME_CONF_EXPERT = 2,
    GPGME_CONF_INVISIBLE = 3,
    GPGME_CONF_INTERNAL = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_conf_type_t {
    GPGME_CONF_NONE = 0,
    GPGME_CONF_STRING = 1,
    GPGME_CONF_INT32 = 2,
    GPGME_CONF_UINT32 = 3,
    GPGME_CONF_FILENAME = 32,
    GPGME_CONF_LDAP_SERVER = 33,
    GPGME_CONF_KEY_FPR = 34,
    GPGME_CONF_PUB_KEY = 35,
    GPGME_CONF_SEC_KEY = 36,
    GPGME_CONF_ALIAS_LIST = 37,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum gpgme_status_code_t {
    GPGME_STATUS_EOF = 0,
    GPGME_STATUS_ENTER = 1,
    GPGME_STATUS_LEAVE = 2,
    GPGME_STATUS_ABORT = 3,
    GPGME_STATUS_GOODSIG = 4,
    GPGME_STATUS_BADSIG = 5,
    GPGME_STATUS_ERRSIG = 6,
    GPGME_STATUS_BADARMOR = 7,
    GPGME_STATUS_RSA_OR_IDEA = 8,
    GPGME_STATUS_KEYEXPIRED = 9,
    GPGME_STATUS_KEYREVOKED = 10,
    GPGME_STATUS_TRUST_UNDEFINED = 11,
    GPGME_STATUS_TRUST_NEVER = 12,
    GPGME_STATUS_TRUST_MARGINAL = 13,
    GPGME_STATUS_TRUST_FULLY = 14,
    GPGME_STATUS_TRUST_ULTIMATE = 15,
    GPGME_STATUS_SHM_INFO = 16,
    GPGME_STATUS_SHM_GET = 17,
    GPGME_STATUS_SHM_GET_BOOL = 18,
    GPGME_STATUS_SHM_GET_HIDDEN = 19,
    GPGME_STATUS_NEED_PASSPHRASE = 20,
    GPGME_STATUS_VALIDSIG = 21,
    GPGME_STATUS_SIG_ID = 22,
    GPGME_STATUS_ENC_TO = 23,
    GPGME_STATUS_NODATA = 24,
    GPGME_STATUS_BAD_PASSPHRASE = 25,
    GPGME_STATUS_NO_PUBKEY = 26,
    GPGME_STATUS_NO_SECKEY = 27,
    GPGME_STATUS_NEED_PASSPHRASE_SYM = 28,
    GPGME_STATUS_DECRYPTION_FAILED = 29,
    GPGME_STATUS_DECRYPTION_OKAY = 30,
    GPGME_STATUS_MISSING_PASSPHRASE = 31,
    GPGME_STATUS_GOOD_PASSPHRASE = 32,
    GPGME_STATUS_GOODMDC = 33,
    GPGME_STATUS_BADMDC = 34,
    GPGME_STATUS_ERRMDC = 35,
    GPGME_STATUS_IMPORTED = 36,
    GPGME_STATUS_IMPORT_OK = 37,
    GPGME_STATUS_IMPORT_PROBLEM = 38,
    GPGME_STATUS_IMPORT_RES = 39,
    GPGME_STATUS_FILE_START = 40,
    GPGME_STATUS_FILE_DONE = 41,
    GPGME_STATUS_FILE_ERROR = 42,
    GPGME_STATUS_BEGIN_DECRYPTION = 43,
    GPGME_STATUS_END_DECRYPTION = 44,
    GPGME_STATUS_BEGIN_ENCRYPTION = 45,
    GPGME_STATUS_END_ENCRYPTION = 46,
    GPGME_STATUS_DELETE_PROBLEM = 47,
    GPGME_STATUS_GET_BOOL = 48,
    GPGME_STATUS_GET_LINE = 49,
    GPGME_STATUS_GET_HIDDEN = 50,
    GPGME_STATUS_GOT_IT = 51,
    GPGME_STATUS_PROGRESS = 52,
    GPGME_STATUS_SIG_CREATED = 53,
    GPGME_STATUS_SESSION_KEY = 54,
    GPGME_STATUS_NOTATION_NAME = 55,
    GPGME_STATUS_NOTATION_DATA = 56,
    GPGME_STATUS_POLICY_URL = 57,
    GPGME_STATUS_BEGIN_STREAM = 58,
    GPGME_STATUS_END_STREAM = 59,
    GPGME_STATUS_KEY_CREATED = 60,
    GPGME_STATUS_USERID_HINT = 61,
    GPGME_STATUS_UNEXPECTED = 62,
    GPGME_STATUS_INV_RECP = 63,
    GPGME_STATUS_NO_RECP = 64,
    GPGME_STATUS_ALREADY_SIGNED = 65,
    GPGME_STATUS_SIGEXPIRED = 66,
    GPGME_STATUS_EXPSIG = 67,
    GPGME_STATUS_EXPKEYSIG = 68,
    GPGME_STATUS_TRUNCATED = 69,
    GPGME_STATUS_ERROR = 70,
    GPGME_STATUS_NEWSIG = 71,
    GPGME_STATUS_REVKEYSIG = 72,
    GPGME_STATUS_SIG_SUBPACKET = 73,
    GPGME_STATUS_NEED_PASSPHRASE_PIN = 74,
    GPGME_STATUS_SC_OP_FAILURE = 75,
    GPGME_STATUS_SC_OP_SUCCESS = 76,
    GPGME_STATUS_CARDCTRL = 77,
    GPGME_STATUS_BACKUP_KEY_CREATED = 78,
    GPGME_STATUS_PKA_TRUST_BAD = 79,
    GPGME_STATUS_PKA_TRUST_GOOD = 80,
    GPGME_STATUS_PLAINTEXT = 81,
    GPGME_STATUS_INV_SGNR = 82,
    GPGME_STATUS_NO_SGNR = 83,
    GPGME_STATUS_SUCCESS = 84,
    GPGME_STATUS_DECRYPTION_INFO = 85,
    GPGME_STATUS_PLAINTEXT_LENGTH = 86,
    GPGME_STATUS_MOUNTPOINT = 87,
    GPGME_STATUS_PINENTRY_LAUNCHED = 88,
    GPGME_STATUS_ATTRIBUTE = 89,
    GPGME_STATUS_BEGIN_SIGNING = 90,
    GPGME_STATUS_KEY_NOT_CREATED = 91,
    GPGME_STATUS_INQUIRE_MAXLEN = 92,
    GPGME_STATUS_FAILURE = 93,
    GPGME_STATUS_KEY_CONSIDERED = 94,
    GPGME_STATUS_TOFU_USER = 95,
    GPGME_STATUS_TOFU_STATS = 96,
    GPGME_STATUS_TOFU_STATS_LONG = 97,
    GPGME_STATUS_NOTATION_FLAGS = 98,
    GPGME_STATUS_DECRYPTION_COMPLIANCE_MODE = 99,
    GPGME_STATUS_VERIFICATION_COMPLIANCE_MODE = 100,
    GPGME_STATUS_CANCELED_BY_USER = 101,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _gpgme_sig_stat_t {
    GPGME_SIG_STAT_NONE = 0,
    GPGME_SIG_STAT_GOOD = 1,
    GPGME_SIG_STAT_BAD = 2,
    GPGME_SIG_STAT_NOKEY = 3,
    GPGME_SIG_STAT_NOSIG = 4,
    GPGME_SIG_STAT_ERROR = 5,
    GPGME_SIG_STAT_DIFF = 6,
    GPGME_SIG_STAT_GOOD_EXP = 7,
    GPGME_SIG_STAT_GOOD_EXPKEY = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _gpgme_attr_t {
    GPGME_ATTR_KEYID = 1,
    GPGME_ATTR_FPR = 2,
    GPGME_ATTR_ALGO = 3,
    GPGME_ATTR_LEN = 4,
    GPGME_ATTR_CREATED = 5,
    GPGME_ATTR_EXPIRE = 6,
    GPGME_ATTR_OTRUST = 7,
    GPGME_ATTR_USERID = 8,
    GPGME_ATTR_NAME = 9,
    GPGME_ATTR_EMAIL = 10,
    GPGME_ATTR_COMMENT = 11,
    GPGME_ATTR_VALIDITY = 12,
    GPGME_ATTR_LEVEL = 13,
    GPGME_ATTR_TYPE = 14,
    GPGME_ATTR_IS_SECRET = 15,
    GPGME_ATTR_KEY_REVOKED = 16,
    GPGME_ATTR_KEY_INVALID = 17,
    GPGME_ATTR_UID_REVOKED = 18,
    GPGME_ATTR_UID_INVALID = 19,
    GPGME_ATTR_KEY_CAPS = 20,
    GPGME_ATTR_CAN_ENCRYPT = 21,
    GPGME_ATTR_CAN_SIGN = 22,
    GPGME_ATTR_CAN_CERTIFY = 23,
    GPGME_ATTR_KEY_EXPIRED = 24,
    GPGME_ATTR_KEY_DISABLED = 25,
    GPGME_ATTR_SERIAL = 26,
    GPGME_ATTR_ISSUER = 27,
    GPGME_ATTR_CHAINID = 28,
    GPGME_ATTR_SIG_STATUS = 29,
    GPGME_ATTR_ERRTOK = 30,
    GPGME_ATTR_SIG_SUMMARY = 31,
    GPGME_ATTR_SIG_CLASS = 32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgme_conf_arg__bindgen_ty_1 {
    pub count: ::core::ffi::c_uint,
    pub uint32: ::core::ffi::c_uint,
    pub int32: ::core::ffi::c_int,
    pub string: *mut ::core::ffi::c_char,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
impl _gpgrt__stream__bindgen_ty_1 {
    #[inline]
    pub fn magic(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_magic(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn writing(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_writing(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        magic: ::core::ffi::c_uint,
        writing: ::core::ffi::c_uint,
        reserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let magic: u32 = unsafe { ::core::mem::transmute(magic) };
            magic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let writing: u32 = unsafe { ::core::mem::transmute(writing) };
            writing as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgrt__stream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_sig_notation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_sig_notation {
    #[inline]
    pub fn human_readable(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_human_readable(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn critical(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_critical(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        human_readable: ::core::ffi::c_uint,
        critical: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let human_readable: u32 = unsafe { ::core::mem::transmute(human_readable) };
            human_readable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let critical: u32 = unsafe { ::core::mem::transmute(critical) };
            critical as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_engine_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_tofu_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_tofu_info {
    #[inline]
    pub fn validity(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_validity(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn policy(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_policy(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _rfu(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__rfu(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        validity: ::core::ffi::c_uint,
        policy: ::core::ffi::c_uint,
        _rfu: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let validity: u32 = unsafe { ::core::mem::transmute(validity) };
            validity as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let policy: u32 = unsafe { ::core::mem::transmute(policy) };
            policy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let _rfu: u32 = unsafe { ::core::mem::transmute(_rfu) };
            _rfu as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_subkey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_subkey {
    #[inline]
    pub fn revoked(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_sign(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_sign(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_certify(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_certify(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secret(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secret(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_authenticate(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_authenticate(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_qualified(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_qualified(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cardkey(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_cardkey(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_renc(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_renc(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_timestamp(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_timestamp(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_group_owned(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_group_owned(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn beta_compliance(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_beta_compliance(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::core::ffi::c_uint,
        expired: ::core::ffi::c_uint,
        disabled: ::core::ffi::c_uint,
        invalid: ::core::ffi::c_uint,
        can_encrypt: ::core::ffi::c_uint,
        can_sign: ::core::ffi::c_uint,
        can_certify: ::core::ffi::c_uint,
        secret: ::core::ffi::c_uint,
        can_authenticate: ::core::ffi::c_uint,
        is_qualified: ::core::ffi::c_uint,
        is_cardkey: ::core::ffi::c_uint,
        is_de_vs: ::core::ffi::c_uint,
        can_renc: ::core::ffi::c_uint,
        can_timestamp: ::core::ffi::c_uint,
        is_group_owned: ::core::ffi::c_uint,
        beta_compliance: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::core::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::core::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u32 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let invalid: u32 = unsafe { ::core::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_encrypt: u32 = unsafe { ::core::mem::transmute(can_encrypt) };
            can_encrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let can_sign: u32 = unsafe { ::core::mem::transmute(can_sign) };
            can_sign as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let can_certify: u32 = unsafe { ::core::mem::transmute(can_certify) };
            can_certify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let secret: u32 = unsafe { ::core::mem::transmute(secret) };
            secret as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let can_authenticate: u32 = unsafe { ::core::mem::transmute(can_authenticate) };
            can_authenticate as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_qualified: u32 = unsafe { ::core::mem::transmute(is_qualified) };
            is_qualified as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_cardkey: u32 = unsafe { ::core::mem::transmute(is_cardkey) };
            is_cardkey as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::core::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let can_renc: u32 = unsafe { ::core::mem::transmute(can_renc) };
            can_renc as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let can_timestamp: u32 = unsafe { ::core::mem::transmute(can_timestamp) };
            can_timestamp as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let is_group_owned: u32 = unsafe { ::core::mem::transmute(is_group_owned) };
            is_group_owned as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let beta_compliance: u32 = unsafe { ::core::mem::transmute(beta_compliance) };
            beta_compliance as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_key_sig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_key_sig {
    #[inline]
    pub fn revoked(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exportable(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exportable(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn trust_depth(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_trust_depth(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn trust_value(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_trust_value(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::core::ffi::c_uint,
        expired: ::core::ffi::c_uint,
        invalid: ::core::ffi::c_uint,
        exportable: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
        trust_depth: ::core::ffi::c_uint,
        trust_value: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::core::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::core::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let invalid: u32 = unsafe { ::core::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exportable: u32 = unsafe { ::core::mem::transmute(exportable) };
            exportable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 12u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let trust_depth: u32 = unsafe { ::core::mem::transmute(trust_depth) };
            trust_depth as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let trust_value: u32 = unsafe { ::core::mem::transmute(trust_value) };
            trust_value as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_user_id {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_user_id {
    #[inline]
    pub fn revoked(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn origin(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_origin(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::core::ffi::c_uint,
        invalid: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
        origin: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::core::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let invalid: u32 = unsafe { ::core::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 25u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let origin: u32 = unsafe { ::core::mem::transmute(origin) };
            origin as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_revocation_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_revocation_key {
    #[inline]
    pub fn sensitive(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sensitive(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sensitive: ::core::ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sensitive: u32 = unsafe { ::core::mem::transmute(sensitive) };
            sensitive as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_key {
    #[inline]
    pub fn revoked(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_revoked(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expired(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expired(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_sign(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_sign(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_certify(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_certify(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secret(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secret(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_authenticate(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_authenticate(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_qualified(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_qualified(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_encrypt(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_encrypt(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_sign(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_sign(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_certify(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_certify(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_authenticate(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_authenticate(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn origin(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_origin(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        revoked: ::core::ffi::c_uint,
        expired: ::core::ffi::c_uint,
        disabled: ::core::ffi::c_uint,
        invalid: ::core::ffi::c_uint,
        can_encrypt: ::core::ffi::c_uint,
        can_sign: ::core::ffi::c_uint,
        can_certify: ::core::ffi::c_uint,
        secret: ::core::ffi::c_uint,
        can_authenticate: ::core::ffi::c_uint,
        is_qualified: ::core::ffi::c_uint,
        has_encrypt: ::core::ffi::c_uint,
        has_sign: ::core::ffi::c_uint,
        has_certify: ::core::ffi::c_uint,
        has_authenticate: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
        origin: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let revoked: u32 = unsafe { ::core::mem::transmute(revoked) };
            revoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let expired: u32 = unsafe { ::core::mem::transmute(expired) };
            expired as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u32 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let invalid: u32 = unsafe { ::core::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_encrypt: u32 = unsafe { ::core::mem::transmute(can_encrypt) };
            can_encrypt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let can_sign: u32 = unsafe { ::core::mem::transmute(can_sign) };
            can_sign as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let can_certify: u32 = unsafe { ::core::mem::transmute(can_certify) };
            can_certify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let secret: u32 = unsafe { ::core::mem::transmute(secret) };
            secret as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let can_authenticate: u32 = unsafe { ::core::mem::transmute(can_authenticate) };
            can_authenticate as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_qualified: u32 = unsafe { ::core::mem::transmute(is_qualified) };
            is_qualified as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let has_encrypt: u32 = unsafe { ::core::mem::transmute(has_encrypt) };
            has_encrypt as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let has_sign: u32 = unsafe { ::core::mem::transmute(has_sign) };
            has_sign as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let has_certify: u32 = unsafe { ::core::mem::transmute(has_certify) };
            has_certify as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let has_authenticate: u32 = unsafe { ::core::mem::transmute(has_authenticate) };
            has_authenticate as u64
        });
        __bindgen_bitfield_unit.set(14usize, 13u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let origin: u32 = unsafe { ::core::mem::transmute(origin) };
            origin as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_invalid_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gpgme_io_cbs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_encrypt_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_ALWAYS_TRUST: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(1);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_NO_ENCRYPT_TO: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(2);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_PREPARE: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(4);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_EXPECT_SIGN: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(8);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_NO_COMPRESS: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(16);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_SYMMETRIC: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(32);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_THROW_KEYIDS: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(64);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_WRAP: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(128);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_WANT_ADDRESS: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(256);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_ARCHIVE: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(512);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_FILE: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(1024);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_ADD_RECP: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(2048);
}
impl gpgme_encrypt_flags_t {
    pub const GPGME_ENCRYPT_CHG_RECP: gpgme_encrypt_flags_t = gpgme_encrypt_flags_t(4096);
}
impl ::core::ops::BitOr<gpgme_encrypt_flags_t> for gpgme_encrypt_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpgme_encrypt_flags_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpgme_encrypt_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpgme_encrypt_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpgme_encrypt_flags_t> for gpgme_encrypt_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpgme_encrypt_flags_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpgme_encrypt_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpgme_encrypt_flags_t) {
        self.0 &= rhs.0;
    }
}
impl Default for _gpgme_recipient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_decrypt_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_op_decrypt_result {
    #[inline]
    pub fn wrong_key_usage(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrong_key_usage(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_mime(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mime(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn legacy_cipher_nomdc(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_legacy_cipher_nomdc(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn beta_compliance(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_beta_compliance(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wrong_key_usage: ::core::ffi::c_uint,
        is_de_vs: ::core::ffi::c_uint,
        is_mime: ::core::ffi::c_uint,
        legacy_cipher_nomdc: ::core::ffi::c_uint,
        beta_compliance: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wrong_key_usage: u32 = unsafe { ::core::mem::transmute(wrong_key_usage) };
            wrong_key_usage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::core::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_mime: u32 = unsafe { ::core::mem::transmute(is_mime) };
            is_mime as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let legacy_cipher_nomdc: u32 = unsafe { ::core::mem::transmute(legacy_cipher_nomdc) };
            legacy_cipher_nomdc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let beta_compliance: u32 = unsafe { ::core::mem::transmute(beta_compliance) };
            beta_compliance as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl gpgme_decrypt_flags_t {
    pub const GPGME_DECRYPT_VERIFY: gpgme_decrypt_flags_t = gpgme_decrypt_flags_t(1);
}
impl gpgme_decrypt_flags_t {
    pub const GPGME_DECRYPT_ARCHIVE: gpgme_decrypt_flags_t = gpgme_decrypt_flags_t(2);
}
impl gpgme_decrypt_flags_t {
    pub const GPGME_DECRYPT_UNWRAP: gpgme_decrypt_flags_t = gpgme_decrypt_flags_t(128);
}
impl ::core::ops::BitOr<gpgme_decrypt_flags_t> for gpgme_decrypt_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpgme_decrypt_flags_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpgme_decrypt_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpgme_decrypt_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpgme_decrypt_flags_t> for gpgme_decrypt_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpgme_decrypt_flags_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpgme_decrypt_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpgme_decrypt_flags_t) {
        self.0 &= rhs.0;
    }
}
impl Default for _gpgme_new_signature {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_sign_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_VALID: gpgme_sigsum_t = gpgme_sigsum_t(1);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_GREEN: gpgme_sigsum_t = gpgme_sigsum_t(2);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_RED: gpgme_sigsum_t = gpgme_sigsum_t(4);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_KEY_REVOKED: gpgme_sigsum_t = gpgme_sigsum_t(16);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_KEY_EXPIRED: gpgme_sigsum_t = gpgme_sigsum_t(32);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_SIG_EXPIRED: gpgme_sigsum_t = gpgme_sigsum_t(64);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_KEY_MISSING: gpgme_sigsum_t = gpgme_sigsum_t(128);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_CRL_MISSING: gpgme_sigsum_t = gpgme_sigsum_t(256);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_CRL_TOO_OLD: gpgme_sigsum_t = gpgme_sigsum_t(512);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_BAD_POLICY: gpgme_sigsum_t = gpgme_sigsum_t(1024);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_SYS_ERROR: gpgme_sigsum_t = gpgme_sigsum_t(2048);
}
impl gpgme_sigsum_t {
    pub const GPGME_SIGSUM_TOFU_CONFLICT: gpgme_sigsum_t = gpgme_sigsum_t(4096);
}
impl ::core::ops::BitOr<gpgme_sigsum_t> for gpgme_sigsum_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        gpgme_sigsum_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for gpgme_sigsum_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: gpgme_sigsum_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<gpgme_sigsum_t> for gpgme_sigsum_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        gpgme_sigsum_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for gpgme_sigsum_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: gpgme_sigsum_t) {
        self.0 &= rhs.0;
    }
}
impl Default for _gpgme_signature {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_signature {
    #[inline]
    pub fn wrong_key_usage(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wrong_key_usage(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pka_trust(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pka_trust(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chain_model(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chain_model(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_de_vs(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_de_vs(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn beta_compliance(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_beta_compliance(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wrong_key_usage: ::core::ffi::c_uint,
        pka_trust: ::core::ffi::c_uint,
        chain_model: ::core::ffi::c_uint,
        is_de_vs: ::core::ffi::c_uint,
        beta_compliance: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wrong_key_usage: u32 = unsafe { ::core::mem::transmute(wrong_key_usage) };
            wrong_key_usage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let pka_trust: u32 = unsafe { ::core::mem::transmute(pka_trust) };
            pka_trust as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let chain_model: u32 = unsafe { ::core::mem::transmute(chain_model) };
            chain_model as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_de_vs: u32 = unsafe { ::core::mem::transmute(is_de_vs) };
            is_de_vs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let beta_compliance: u32 = unsafe { ::core::mem::transmute(beta_compliance) };
            beta_compliance as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_op_verify_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_op_verify_result {
    #[inline]
    pub fn is_mime(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mime(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_mime: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_mime: u32 = unsafe { ::core::mem::transmute(is_mime) };
            is_mime as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_import_status {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_import_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_genkey_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_op_genkey_result {
    #[inline]
    pub fn primary(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_primary(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sub(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sub(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uid(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uid(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        primary: ::core::ffi::c_uint,
        sub: ::core::ffi::c_uint,
        uid: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let primary: u32 = unsafe { ::core::mem::transmute(primary) };
            primary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sub: u32 = unsafe { ::core::mem::transmute(sub) };
            sub as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let uid: u32 = unsafe { ::core::mem::transmute(uid) };
            uid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _gpgme_op_keylist_result {
    #[inline]
    pub fn truncated(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_truncated(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _unused(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set__unused(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        truncated: ::core::ffi::c_uint,
        _unused: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let truncated: u32 = unsafe { ::core::mem::transmute(truncated) };
            truncated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let _unused: u32 = unsafe { ::core::mem::transmute(_unused) };
            _unused as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _gpgme_trust_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_vfs_mount_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gpgme_conf_arg__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for gpgme_conf_arg__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "gpgme_conf_arg__bindgen_ty_1 {{ union }}")
    }
}
impl Default for gpgme_conf_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for gpgme_conf_arg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "gpgme_conf_arg {{ next: {:?}, no_arg: {:?}, value: {:?} }}",
            self.next, self.no_arg, self.value
        )
    }
}
impl Default for gpgme_conf_opt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gpgme_conf_comp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _gpgme_op_query_swdb_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _gpgme_op_query_swdb_result {
    #[inline]
    pub fn warning(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_warning(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urgent(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_urgent(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noinfo(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noinfo(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unknown(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tooold(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tooold(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set__reserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        warning: ::core::ffi::c_uint,
        update: ::core::ffi::c_uint,
        urgent: ::core::ffi::c_uint,
        noinfo: ::core::ffi::c_uint,
        unknown: ::core::ffi::c_uint,
        tooold: ::core::ffi::c_uint,
        error: ::core::ffi::c_uint,
        _reserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let warning: u32 = unsafe { ::core::mem::transmute(warning) };
            warning as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let update: u32 = unsafe { ::core::mem::transmute(update) };
            update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let urgent: u32 = unsafe { ::core::mem::transmute(urgent) };
            urgent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let noinfo: u32 = unsafe { ::core::mem::transmute(noinfo) };
            noinfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unknown: u32 = unsafe { ::core::mem::transmute(unknown) };
            unknown as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tooold: u32 = unsafe { ::core::mem::transmute(tooold) };
            tooold as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let _reserved: u32 = unsafe { ::core::mem::transmute(_reserved) };
            _reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub use self::_gpgme_attr_t as gpgme_attr_t;
pub use self::_gpgme_sig_stat_t as gpgme_sig_stat_t;
pub use self::gpg_err_code_t as gpgme_err_code_t;
pub use self::gpg_err_source_t as gpgme_err_source_t;
pub use self::gpgme_attr_t as GpgmeAttr;
pub use self::gpgme_data_encoding_t as GpgmeDataEncoding;
pub use self::gpgme_event_io_t as GpgmeEventIO;
pub use self::gpgme_hash_algo_t as GpgmeHashAlgo;
pub use self::gpgme_protocol_t as GpgmeProtocol;
pub use self::gpgme_pubkey_algo_t as GpgmePubKeyAlgo;
pub use self::gpgme_sig_mode_t as GpgmeSigMode;
pub use self::gpgme_sig_stat_t as GpgmeSigStat;
pub use self::gpgme_status_code_t as GpgmeStatusCode;
pub use self::gpgme_validity_t as GpgmeValidity;
